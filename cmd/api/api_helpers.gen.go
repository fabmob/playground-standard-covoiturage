// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.2 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/labstack/echo/v4"
)

// Defines values for CarpoolBookingStatus.
const (
	CarpoolBookingStatusCANCELLED                  CarpoolBookingStatus = "CANCELLED"
	CarpoolBookingStatusCOMPLETEDPENDINGVALIDATION CarpoolBookingStatus = "COMPLETED_PENDING_VALIDATION"
	CarpoolBookingStatusCONFIRMED                  CarpoolBookingStatus = "CONFIRMED"
	CarpoolBookingStatusVALIDATED                  CarpoolBookingStatus = "VALIDATED"
	CarpoolBookingStatusWAITINGCONFIRMATION        CarpoolBookingStatus = "WAITING_CONFIRMATION"
)

// Defines values for JourneyScheduleType.
const (
	DYNAMIC JourneyScheduleType = "DYNAMIC"
	LINE    JourneyScheduleType = "LINE"
	PLANNED JourneyScheduleType = "PLANNED"
)

// Defines values for PriceType.
const (
	FREE    PriceType = "FREE"
	PAYING  PriceType = "PAYING"
	UNKNOWN PriceType = "UNKNOWN"
)

// Defines values for SchedulePassengerPickupDay.
const (
	FRI SchedulePassengerPickupDay = "FRI"
	MON SchedulePassengerPickupDay = "MON"
	SAT SchedulePassengerPickupDay = "SAT"
	SUN SchedulePassengerPickupDay = "SUN"
	THU SchedulePassengerPickupDay = "THU"
	TUE SchedulePassengerPickupDay = "TUE"
	WED SchedulePassengerPickupDay = "WED"
)

// Defines values for UserGender.
const (
	F UserGender = "F"
	M UserGender = "M"
	O UserGender = "O"
)

// Defines values for BookingStatus.
const (
	BookingStatusCANCELLED                  BookingStatus = "CANCELLED"
	BookingStatusCOMPLETEDPENDINGVALIDATION BookingStatus = "COMPLETED_PENDING_VALIDATION"
	BookingStatusCONFIRMED                  BookingStatus = "CONFIRMED"
	BookingStatusVALIDATED                  BookingStatus = "VALIDATED"
	BookingStatusWAITINGCONFIRMATION        BookingStatus = "WAITING_CONFIRMATION"
)

// Defines values for PostConnectionsJSONBodyRecipientCarpoolerType.
const (
	DRIVER    PostConnectionsJSONBodyRecipientCarpoolerType = "DRIVER"
	PASSENGER PostConnectionsJSONBodyRecipientCarpoolerType = "PASSENGER"
)

// Booking defines model for Booking.
type Booking struct {
	Car *Car `json:"car,omitempty"`

	// Distance Carpooling distance in meters.
	Distance *int `json:"distance,omitempty"`
	Driver   User `json:"driver"`

	// DriverJourneyId ID of the Driver's journey to which the booking is related (if any). Unique given the `User`'s `operator` property.
	DriverJourneyId *string `json:"driverJourneyId,omitempty"`

	// Duration Carpooling duration in seconds.
	Duration *int `json:"duration,omitempty"`

	// Id Booking id is common between both operators, and must be created as a [UUID](https://datatracker.ietf.org/doc/html/rfc4122) by whoever initiates the booking.  Usage of a [4 UUID](https://datatracker.ietf.org/doc/html/rfc4122#section-4.4) generation algorithm is advised.
	Id        BookingId `json:"id"`
	Passenger User      `json:"passenger"`

	// PassengerDropAddress String representing the drop-off address.
	PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

	// PassengerDropLat Latitude of the passenger drop-off point.
	PassengerDropLat float64 `json:"passengerDropLat"`

	// PassengerDropLng Longitude of the passenger drop-off point.
	PassengerDropLng float64 `json:"passengerDropLng"`

	// PassengerJourneyId ID of the Passenger's journey to which the booking is related (if any). Unique given the `User`'s `operator` property.
	PassengerJourneyId *string `json:"passengerJourneyId,omitempty"`

	// PassengerPickupAddress String representing the pickup-up address.
	PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

	// PassengerPickupDate Passenger pickup datetime as a UNIX UTC timestamp in seconds.
	PassengerPickupDate int64 `json:"passengerPickupDate"`

	// PassengerPickupLat Latitude of the passenger pick-up point.
	PassengerPickupLat float64 `json:"passengerPickupLat"`

	// PassengerPickupLng Longitude of the passenger pick-up point.
	PassengerPickupLng float64 `json:"passengerPickupLng"`
	Price              Price   `json:"price"`

	// Status Status of the booking.
	Status BookingStatus `json:"status"`

	// WebUrl URL of the booking on the webservice provider platform.
	WebUrl *string `json:"webUrl,omitempty"`
}

// Car defines model for Car.
type Car struct {
	// Brand Brand of the car.
	Brand *string `json:"brand,omitempty"`

	// Model Model of the car.
	Model *string `json:"model,omitempty"`
}

// CarpoolBooking defines model for CarpoolBooking.
type CarpoolBooking struct {
	// Distance Carpooling distance in meters. When the booking is COMPLETED or VALIDATED, this is the actual distance travelled if available.
	Distance *int `json:"distance,omitempty"`

	// Duration Carpooling duration in seconds.
	Duration *int `json:"duration,omitempty"`

	// Id Unique identifier of the booking.
	Id openapi_types.UUID `json:"id"`

	// PassengerDropAddress String representing the drop-off address.
	PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

	// PassengerDropLat Latitude of the passenger drop-off point.
	PassengerDropLat float64 `json:"passengerDropLat"`

	// PassengerDropLng Longitude of the passenger drop-off point.
	PassengerDropLng float64 `json:"passengerDropLng"`

	// PassengerPickupAddress String representing the pickup-up address.
	PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

	// PassengerPickupDate Passenger pickup datetime as a UNIX UTC timestamp in seconds.
	PassengerPickupDate int64 `json:"passengerPickupDate"`

	// PassengerPickupLat Latitude of the passenger pick-up point.
	PassengerPickupLat float64 `json:"passengerPickupLat"`

	// PassengerPickupLng Longitude of the passenger pick-up point.
	PassengerPickupLng float64              `json:"passengerPickupLng"`
	Status             CarpoolBookingStatus `json:"status"`

	// WebUrl URL of the booking on the webservice provider platform.
	WebUrl string `json:"webUrl"`
}

// CarpoolBookingStatus defines model for CarpoolBooking.Status.
type CarpoolBookingStatus string

// CarpoolBookingEvent defines model for CarpoolBookingEvent.
type CarpoolBookingEvent struct {
	Data CarpoolBookingEvent_Data `json:"data"`

	// Id Unique journey's id in the format of an [UUID](https://datatracker.ietf.org/doc/html/rfc4122). Usage of a [4 UUID](https://datatracker.ietf.org/doc/html/rfc4122#section-4.4) generation algorithm is advised.
	Id openapi_types.UUID `json:"id"`

	// IdToken ID token of the user retrieved using the OpenID Connect flows.
	IdToken string `json:"idToken"`
}

// CarpoolBookingEvent_Data defines model for CarpoolBookingEvent.Data.
type CarpoolBookingEvent_Data struct {
	union json.RawMessage
}

// DriverCarpoolBooking defines model for DriverCarpoolBooking.
type DriverCarpoolBooking struct {
	// Embedded struct due to allOf(#/components/schemas/CarpoolBooking)
	CarpoolBooking `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Car    *Car  `json:"car,omitempty"`
	Driver User  `json:"driver"`
	Price  Price `json:"price"`
}

// DriverJourney defines model for DriverJourney.
type DriverJourney struct {
	// Embedded struct due to allOf(#/components/schemas/DriverTrip)
	DriverTrip `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/JourneySchedule)
	JourneySchedule `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// AvailableSeats Available seats in the car.
	AvailableSeats *int   `json:"availableSeats,omitempty"`
	Price          *Price `json:"price,omitempty"`
}

// DriverTrip defines model for DriverTrip.
type DriverTrip struct {
	// Embedded struct due to allOf(#/components/schemas/Trip)
	Trip `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Car *Car `json:"car,omitempty"`

	// DepartureToPickupWalkingDistance Walking distance from the requested departure location
	// to the pick-up location.
	DepartureToPickupWalkingDistance *int `json:"departureToPickupWalkingDistance,omitempty"`

	// DepartureToPickupWalkingDuration Walking duration from the requested departure location
	// to the pick-up location.
	DepartureToPickupWalkingDuration *int `json:"departureToPickupWalkingDuration,omitempty"`

	// DepartureToPickupWalkingPolyline Walking
	// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
	// from the requested departure location to the pick-up location.
	DepartureToPickupWalkingPolyline *string `json:"departureToPickupWalkingPolyline,omitempty"`
	Driver                           User    `json:"driver"`

	// DropoffToArrivalWalkingDistance Walking distance to the requested arrival location
	// from the drop-off location.
	DropoffToArrivalWalkingDistance *int `json:"dropoffToArrivalWalkingDistance,omitempty"`

	// DropoffToArrivalWalkingDuration Walking duration to the requested arrival location
	// from the drop-off location.
	DropoffToArrivalWalkingDuration *int `json:"dropoffToArrivalWalkingDuration,omitempty"`

	// DropoffToArrivalWalkingPolyline Walking
	// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
	// to the requested arrival location from the drop-off location.
	DropoffToArrivalWalkingPolyline *string `json:"dropoffToArrivalWalkingPolyline,omitempty"`
}

// JourneySchedule defines model for JourneySchedule.
type JourneySchedule struct {
	// DriverDepartureDate Driver departure datetime as a UNIX UTC timestamp in seconds.
	DriverDepartureDate *int64 `json:"driverDepartureDate,omitempty"`

	// Id Journey's id. It MUST be unique for a given operator.
	Id *string `json:"id,omitempty"`

	// PassengerPickupDate Passenger pickup datetime as a UNIX UTC timestamp in seconds.
	PassengerPickupDate int64 `json:"passengerPickupDate"`

	// Type Type of journey. A dynamic journey is happening in real time.
	Type JourneyScheduleType `json:"type"`

	// WebUrl URL of the journey on the webservice provider platform. Required to support booking by deeplink.
	WebUrl *string `json:"webUrl,omitempty"`
}

// JourneyScheduleType Type of journey. A dynamic journey is happening in real time.
type JourneyScheduleType string

// PassengerCarpoolBooking defines model for PassengerCarpoolBooking.
type PassengerCarpoolBooking struct {
	// Embedded struct due to allOf(#/components/schemas/CarpoolBooking)
	CarpoolBooking `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Passenger User `json:"passenger"`
}

// PassengerJourney defines model for PassengerJourney.
type PassengerJourney struct {
	// Embedded struct due to allOf(#/components/schemas/PassengerTrip)
	PassengerTrip `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/JourneySchedule)
	JourneySchedule `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// RequestedSeats Requested seats by the passenger.
	RequestedSeats *int `json:"requestedSeats,omitempty"`
}

// PassengerTrip defines model for PassengerTrip.
type PassengerTrip struct {
	// Embedded struct due to allOf(#/components/schemas/Trip)
	Trip `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Passenger User `json:"passenger"`
}

// Preferences defines model for Preferences.
type Preferences struct {
	// Animals If driver journey, specifies if the driver allows animals in the car.
	Animals *bool `json:"animals,omitempty"`

	// IsTalker If driver journey, specifies if the driver enjoys talking with passengers.
	IsTalker *bool `json:"isTalker,omitempty"`

	// LuggageSize If driver journey, specifies the size of allowed luggages.
	// From very small (1) to very big (5).
	LuggageSize *int `json:"luggageSize,omitempty"`

	// Music If driver journey, specifies if the driver enjoys music in the car.
	Music *bool `json:"music,omitempty"`

	// Smoking If driver journey, specifies if the driver allows smoking in the car.
	Smoking *bool `json:"smoking,omitempty"`
}

// Price defines model for Price.
type Price struct {
	// Amount Carpooling passenger cost estimate. In the case of integrated booking by API, amount expected by the carpooling operator.
	Amount *float32 `json:"amount,omitempty"`

	// Currency ISO 4217 code representing the currency of the price.
	Currency *string `json:"currency,omitempty"`

	// Type Either « FREE », « PAYING » or « UNKNOWN ». « UNKNOWN » is given
	// when it should be « PAYING » but we cannot set the price yet.
	Type *PriceType `json:"type,omitempty"`
}

// PriceType Either « FREE », « PAYING » or « UNKNOWN ». « UNKNOWN » is given
// when it should be « PAYING » but we cannot set the price yet.
type PriceType string

// Schedule defines model for Schedule.
type Schedule struct {
	JourneySchedules *[]JourneySchedule `json:"journeySchedules,omitempty"`

	// PassengerPickupDay Day of week of the passenger pick-up.
	PassengerPickupDay *SchedulePassengerPickupDay `json:"passengerPickupDay,omitempty"`

	// PassengerPickupTimeOfDay Passenger pick-up time of day represented as
	// [RFC3339 partial-time](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6).
	PassengerPickupTimeOfDay *string `json:"passengerPickupTimeOfDay,omitempty"`
}

// SchedulePassengerPickupDay Day of week of the passenger pick-up.
type SchedulePassengerPickupDay string

// Trip defines model for Trip.
type Trip struct {
	// Distance Carpooling distance in meters.
	Distance *int `json:"distance,omitempty"`

	// DriverArrivalAddress String representing the arrival address of the driver.
	DriverArrivalAddress *string `json:"driverArrivalAddress,omitempty"`

	// DriverArrivalLat Latitude of the arrival.
	DriverArrivalLat *float64 `json:"driverArrivalLat,omitempty"`

	// DriverArrivalLng Longitude of the arrival.
	DriverArrivalLng *float64 `json:"driverArrivalLng,omitempty"`

	// DriverDepartureAddress String representing the departure address of the driver.
	DriverDepartureAddress *string `json:"driverDepartureAddress,omitempty"`

	// DriverDepartureLat Latitude of the departure.
	DriverDepartureLat *float64 `json:"driverDepartureLat,omitempty"`

	// DriverDepartureLng Longitude of the departure.
	DriverDepartureLng *float64 `json:"driverDepartureLng,omitempty"`

	// Duration Carpooling duration in seconds.
	Duration int `json:"duration"`

	// JourneyPolyline Carpooling journey itinerary as a
	// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm), compressed at  level 5.
	JourneyPolyline *string `json:"journeyPolyline,omitempty"`

	// Operator The operator identifier. MUST be a Root Domain (example operator.org) owned by the operator or a Fully Qualified Domain Name (example carpool.mycity.com) exclusively operated by the operator. A given operator SHOULD always send the same value.
	Operator string `json:"operator"`

	// PassengerDropAddress String representing the drop-off address.
	PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

	// PassengerDropLat Latitude of the passenger drop-off point.
	PassengerDropLat float64 `json:"passengerDropLat"`

	// PassengerDropLng Longitude of the passenger drop-off point.
	PassengerDropLng float64 `json:"passengerDropLng"`

	// PassengerPickupAddress String representing the pickup-up address.
	PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

	// PassengerPickupLat Latitude of the passenger pick-up point.
	PassengerPickupLat float64 `json:"passengerPickupLat"`

	// PassengerPickupLng Longitude of the passenger pick-up point.
	PassengerPickupLng float64      `json:"passengerPickupLng"`
	Preferences        *Preferences `json:"preferences,omitempty"`

	// WebUrl URL of the trip on the webservice provider platform.
	WebUrl *string `json:"webUrl,omitempty"`
}

// User defines model for User.
type User struct {
	// Alias User's alias.
	Alias string `json:"alias"`

	// FirstName User's first name.
	FirstName *string `json:"firstName,omitempty"`

	// Gender User's gender. 'O' stands for 'Other'.
	Gender *UserGender `json:"gender,omitempty"`

	// Grade User's grade from 1 to 5.
	Grade *int `json:"grade,omitempty"`

	// Id User's identifier. It MUST be unique for a given `operator`.
	Id string `json:"id"`

	// LastName User's last name.
	LastName *string `json:"lastName,omitempty"`

	// Operator The operator identifier. MUST be a Fully Qualified Domain Name (example carpool.mycity.com) owned by the operator or a Partially Qualified Domain Name (example operator.org) owned and exclusively operated by the operator. Operators SHOULD always send the same value.
	Operator string `json:"operator"`

	// Picture User's profile picture absolute URL.
	Picture *string `json:"picture,omitempty"`

	// VerifiedIdentity true if the identity of this user has been verified by the operator or a third party; and the firstName, lastName, birthdate have been confirmed as identitical to an official identity proof document. Can be left empty if the information is not available.
	VerifiedIdentity *bool `json:"verifiedIdentity,omitempty"`
}

// UserGender User's gender. 'O' stands for 'Other'.
type UserGender string

// BookingId Booking id is common between both operators, and must be created as a [UUID](https://datatracker.ietf.org/doc/html/rfc4122) by whoever initiates the booking.  Usage of a [4 UUID](https://datatracker.ietf.org/doc/html/rfc4122#section-4.4) generation algorithm is advised.
type BookingId = openapi_types.UUID

// BookingStatus Status of the booking.
type BookingStatus string

// ArrivalLat defines model for arrivalLat.
type ArrivalLat = float32

// ArrivalLng defines model for arrivalLng.
type ArrivalLng = float32

// ArrivalRadius defines model for arrivalRadius.
type ArrivalRadius = float32

// Count defines model for count.
type Count = int

// DepartureDate defines model for departureDate.
type DepartureDate = int

// DepartureLat defines model for departureLat.
type DepartureLat = float32

// DepartureLng defines model for departureLng.
type DepartureLng = float32

// DepartureRadius defines model for departureRadius.
type DepartureRadius = float32

// DepartureTimeOfDay defines model for departureTimeOfDay.
type DepartureTimeOfDay = string

// DepartureWeekdays defines model for departureWeekdays.
type DepartureWeekdays = []string

// MaxDepartureDate defines model for maxDepartureDate.
type MaxDepartureDate = int

// MinDepartureDate defines model for minDepartureDate.
type MinDepartureDate = int

// TimeDelta defines model for timeDelta.
type TimeDelta = int

// BadRequest defines model for BadRequest.
type BadRequest struct {
	// Error Explain why the request couldn't be processed.
	Error *string `json:"error,omitempty"`
}

// PatchBookingsParams defines parameters for PatchBookings.
type PatchBookingsParams struct {
	// Status New status of the Booking.
	Status BookingStatus `form:"status" json:"status"`

	// Message Free text content of a message. The message can contain explanations on the status change.
	Message *string `form:"message,omitempty" json:"message,omitempty"`
}

// GetDriverJourneysParams defines parameters for GetDriverJourneys.
type GetDriverJourneysParams struct {
	// DepartureLat Latitude of searched departure point.
	DepartureLat DepartureLat `form:"departureLat" json:"departureLat"`

	// DepartureLng Longitude of searched departure point.
	DepartureLng DepartureLng `form:"departureLng" json:"departureLng"`

	// ArrivalLat Latitude of searched arrival point.
	ArrivalLat ArrivalLat `form:"arrivalLat" json:"arrivalLat"`

	// ArrivalLng Longitude of searched arrival point.
	ArrivalLng ArrivalLng `form:"arrivalLng" json:"arrivalLng"`

	// DepartureDate Departure datetime using a UNIX UTC timestamp in seconds.
	DepartureDate DepartureDate `form:"departureDate" json:"departureDate"`

	// TimeDelta Time margin in seconds. The retrieved journeys must match the given time parameters within a +`timeDelta` / -`timeDelta` interval .
	TimeDelta *TimeDelta `form:"timeDelta,omitempty" json:"timeDelta,omitempty"`

	// DepartureRadius Search radius in kilometers around the departure point.
	DepartureRadius *DepartureRadius `form:"departureRadius,omitempty" json:"departureRadius,omitempty"`

	// ArrivalRadius Search radius in kilometers around the arrival point.
	ArrivalRadius *ArrivalRadius `form:"arrivalRadius,omitempty" json:"arrivalRadius,omitempty"`

	// Count Maximum number of returned results. If missing, all matching results are returned.
	Count *Count `form:"count,omitempty" json:"count,omitempty"`
}

// GetDriverRegularTripsParams defines parameters for GetDriverRegularTrips.
type GetDriverRegularTripsParams struct {
	// DepartureLat Latitude of searched departure point.
	DepartureLat DepartureLat `form:"departureLat" json:"departureLat"`

	// DepartureLng Longitude of searched departure point.
	DepartureLng DepartureLng `form:"departureLng" json:"departureLng"`

	// ArrivalLat Latitude of searched arrival point.
	ArrivalLat ArrivalLat `form:"arrivalLat" json:"arrivalLat"`

	// ArrivalLng Longitude of searched arrival point.
	ArrivalLng ArrivalLng `form:"arrivalLng" json:"arrivalLng"`

	// DepartureTimeOfDay Departure time of day represented as [RFC3339 partial-time](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6).
	DepartureTimeOfDay DepartureTimeOfDay `form:"departureTimeOfDay" json:"departureTimeOfDay"`

	// DepartureWeekdays Departure days of week. The retrieved trips should have at least one schedule applicable on one of the departureWeekdays.
	DepartureWeekdays *DepartureWeekdays `form:"departureWeekdays,omitempty" json:"departureWeekdays,omitempty"`

	// TimeDelta Time margin in seconds. The retrieved journeys must match the given time parameters within a +`timeDelta` / -`timeDelta` interval .
	TimeDelta *TimeDelta `form:"timeDelta,omitempty" json:"timeDelta,omitempty"`

	// DepartureRadius Search radius in kilometers around the departure point.
	DepartureRadius *DepartureRadius `form:"departureRadius,omitempty" json:"departureRadius,omitempty"`

	// ArrivalRadius Search radius in kilometers around the arrival point.
	ArrivalRadius *ArrivalRadius `form:"arrivalRadius,omitempty" json:"arrivalRadius,omitempty"`

	// MinDepartureDate Minimum date of departure for the returned journeys. Datetime using a UNIX UTC timestamp in seconds.
	MinDepartureDate *MinDepartureDate `form:"minDepartureDate,omitempty" json:"minDepartureDate,omitempty"`

	// MaxDepartureDate Maximum date of departure for the returned journeys. Datetime using a UNIX UTC timestamp in seconds.
	MaxDepartureDate *MaxDepartureDate `form:"maxDepartureDate,omitempty" json:"maxDepartureDate,omitempty"`

	// Count Maximum number of returned results. If missing, all matching results are returned.
	Count *Count `form:"count,omitempty" json:"count,omitempty"`
}

// PostConnectionsJSONBody defines parameters for PostConnections.
type PostConnectionsJSONBody struct {
	// BookingId Booking id is common between both operators, and must be created as a [UUID](https://datatracker.ietf.org/doc/html/rfc4122) by whoever initiates the booking.  Usage of a [4 UUID](https://datatracker.ietf.org/doc/html/rfc4122#section-4.4) generation algorithm is advised.
	BookingId *BookingId `json:"bookingId,omitempty"`

	// DriverJourneyId ID of the Driver's journey to which the message is related (if any). Unique given the `Driver`'s `operator` property.
	DriverJourneyId *string `json:"driverJourneyId,omitempty"`
	From            User    `json:"from"`

	// Message Free text content of a message. The message can contain all the details (phone number, email, etc.) allowing the recipient to call back the sender in order to carpool with him/her.
	Message string `json:"message"`

	// PassengerJourneyId ID of the Passenger's journey to which the message is related (if any). Unique given the `Passenger`'s `operator` property.
	PassengerJourneyId *string `json:"passengerJourneyId,omitempty"`

	// RecipientCarpoolerType Defines if the recipient of this message is either the driver or the passenger.
	RecipientCarpoolerType PostConnectionsJSONBodyRecipientCarpoolerType `json:"recipientCarpoolerType"`
	To                     User                                          `json:"to"`
}

// PostConnectionsJSONBodyRecipientCarpoolerType defines parameters for PostConnections.
type PostConnectionsJSONBodyRecipientCarpoolerType string

// GetPassengerJourneysParams defines parameters for GetPassengerJourneys.
type GetPassengerJourneysParams struct {
	// DepartureLat Latitude of searched departure point.
	DepartureLat DepartureLat `form:"departureLat" json:"departureLat"`

	// DepartureLng Longitude of searched departure point.
	DepartureLng DepartureLng `form:"departureLng" json:"departureLng"`

	// ArrivalLat Latitude of searched arrival point.
	ArrivalLat ArrivalLat `form:"arrivalLat" json:"arrivalLat"`

	// ArrivalLng Longitude of searched arrival point.
	ArrivalLng ArrivalLng `form:"arrivalLng" json:"arrivalLng"`

	// DepartureDate Departure datetime using a UNIX UTC timestamp in seconds.
	DepartureDate DepartureDate `form:"departureDate" json:"departureDate"`

	// TimeDelta Time margin in seconds. The retrieved journeys must match the given time parameters within a +`timeDelta` / -`timeDelta` interval .
	TimeDelta *TimeDelta `form:"timeDelta,omitempty" json:"timeDelta,omitempty"`

	// DepartureRadius Search radius in kilometers around the departure point.
	DepartureRadius *DepartureRadius `form:"departureRadius,omitempty" json:"departureRadius,omitempty"`

	// ArrivalRadius Search radius in kilometers around the arrival point.
	ArrivalRadius *ArrivalRadius `form:"arrivalRadius,omitempty" json:"arrivalRadius,omitempty"`

	// Count Maximum number of returned results. If missing, all matching results are returned.
	Count *Count `form:"count,omitempty" json:"count,omitempty"`
}

// GetPassengerRegularTripsParams defines parameters for GetPassengerRegularTrips.
type GetPassengerRegularTripsParams struct {
	// DepartureLat Latitude of searched departure point.
	DepartureLat DepartureLat `form:"departureLat" json:"departureLat"`

	// DepartureLng Longitude of searched departure point.
	DepartureLng DepartureLng `form:"departureLng" json:"departureLng"`

	// ArrivalLat Latitude of searched arrival point.
	ArrivalLat ArrivalLat `form:"arrivalLat" json:"arrivalLat"`

	// ArrivalLng Longitude of searched arrival point.
	ArrivalLng ArrivalLng `form:"arrivalLng" json:"arrivalLng"`

	// DepartureTimeOfDay Departure time of day represented as [RFC3339 partial-time](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6).
	DepartureTimeOfDay DepartureTimeOfDay `form:"departureTimeOfDay" json:"departureTimeOfDay"`

	// DepartureWeekdays Departure days of week. The retrieved trips should have at least one schedule applicable on one of the departureWeekdays.
	DepartureWeekdays *DepartureWeekdays `form:"departureWeekdays,omitempty" json:"departureWeekdays,omitempty"`

	// TimeDelta Time margin in seconds. The retrieved journeys must match the given time parameters within a +`timeDelta` / -`timeDelta` interval .
	TimeDelta *TimeDelta `form:"timeDelta,omitempty" json:"timeDelta,omitempty"`

	// DepartureRadius Search radius in kilometers around the departure point.
	DepartureRadius *DepartureRadius `form:"departureRadius,omitempty" json:"departureRadius,omitempty"`

	// ArrivalRadius Search radius in kilometers around the arrival point.
	ArrivalRadius *ArrivalRadius `form:"arrivalRadius,omitempty" json:"arrivalRadius,omitempty"`

	// MinDepartureDate Minimum date of departure for the returned journeys. Datetime using a UNIX UTC timestamp in seconds.
	MinDepartureDate *MinDepartureDate `form:"minDepartureDate,omitempty" json:"minDepartureDate,omitempty"`

	// MaxDepartureDate Maximum date of departure for the returned journeys. Datetime using a UNIX UTC timestamp in seconds.
	MaxDepartureDate *MaxDepartureDate `form:"maxDepartureDate,omitempty" json:"maxDepartureDate,omitempty"`

	// Count Maximum number of returned results. If missing, all matching results are returned.
	Count *Count `form:"count,omitempty" json:"count,omitempty"`
}

// PostBookingEventsJSONRequestBody defines body for PostBookingEvents for application/json ContentType.
type PostBookingEventsJSONRequestBody = CarpoolBookingEvent

// PostBookingsJSONRequestBody defines body for PostBookings for application/json ContentType.
type PostBookingsJSONRequestBody = Booking

// PostConnectionsJSONRequestBody defines body for PostConnections for application/json ContentType.
type PostConnectionsJSONRequestBody PostConnectionsJSONBody

// AsDriverCarpoolBooking returns the union data inside the CarpoolBookingEvent_Data as a DriverCarpoolBooking
func (t CarpoolBookingEvent_Data) AsDriverCarpoolBooking() (DriverCarpoolBooking, error) {
	var body DriverCarpoolBooking
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDriverCarpoolBooking overwrites any union data inside the CarpoolBookingEvent_Data as the provided DriverCarpoolBooking
func (t *CarpoolBookingEvent_Data) FromDriverCarpoolBooking(v DriverCarpoolBooking) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDriverCarpoolBooking performs a merge with any union data inside the CarpoolBookingEvent_Data, using the provided DriverCarpoolBooking
func (t *CarpoolBookingEvent_Data) MergeDriverCarpoolBooking(v DriverCarpoolBooking) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPassengerCarpoolBooking returns the union data inside the CarpoolBookingEvent_Data as a PassengerCarpoolBooking
func (t CarpoolBookingEvent_Data) AsPassengerCarpoolBooking() (PassengerCarpoolBooking, error) {
	var body PassengerCarpoolBooking
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPassengerCarpoolBooking overwrites any union data inside the CarpoolBookingEvent_Data as the provided PassengerCarpoolBooking
func (t *CarpoolBookingEvent_Data) FromPassengerCarpoolBooking(v PassengerCarpoolBooking) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePassengerCarpoolBooking performs a merge with any union data inside the CarpoolBookingEvent_Data, using the provided PassengerCarpoolBooking
func (t *CarpoolBookingEvent_Data) MergePassengerCarpoolBooking(v PassengerCarpoolBooking) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CarpoolBookingEvent_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CarpoolBookingEvent_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostBookingEvents request with any body
	PostBookingEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBookingEvents(ctx context.Context, body PostBookingEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBookings request with any body
	PostBookingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBookings(ctx context.Context, body PostBookingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBookings request
	GetBookings(ctx context.Context, bookingId BookingId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchBookings request
	PatchBookings(ctx context.Context, bookingId BookingId, params *PatchBookingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDriverJourneys request
	GetDriverJourneys(ctx context.Context, params *GetDriverJourneysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDriverRegularTrips request
	GetDriverRegularTrips(ctx context.Context, params *GetDriverRegularTripsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostConnections request with any body
	PostConnectionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostConnections(ctx context.Context, body PostConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPassengerJourneys request
	GetPassengerJourneys(ctx context.Context, params *GetPassengerJourneysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPassengerRegularTrips request
	GetPassengerRegularTrips(ctx context.Context, params *GetPassengerRegularTripsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostBookingEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBookingEventsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBookingEvents(ctx context.Context, body PostBookingEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBookingEventsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBookingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBookingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBookings(ctx context.Context, body PostBookingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBookingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBookings(ctx context.Context, bookingId BookingId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBookingsRequest(c.Server, bookingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchBookings(ctx context.Context, bookingId BookingId, params *PatchBookingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchBookingsRequest(c.Server, bookingId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDriverJourneys(ctx context.Context, params *GetDriverJourneysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDriverJourneysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDriverRegularTrips(ctx context.Context, params *GetDriverRegularTripsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDriverRegularTripsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostConnectionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostConnectionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostConnections(ctx context.Context, body PostConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostConnectionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPassengerJourneys(ctx context.Context, params *GetPassengerJourneysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPassengerJourneysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPassengerRegularTrips(ctx context.Context, params *GetPassengerRegularTripsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPassengerRegularTripsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostBookingEventsRequest calls the generic PostBookingEvents builder with application/json body
func NewPostBookingEventsRequest(server string, body PostBookingEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBookingEventsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBookingEventsRequestWithBody generates requests for PostBookingEvents with any type of body
func NewPostBookingEventsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/booking_events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostBookingsRequest calls the generic PostBookings builder with application/json body
func NewPostBookingsRequest(server string, body PostBookingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBookingsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBookingsRequestWithBody generates requests for PostBookings with any type of body
func NewPostBookingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBookingsRequest generates requests for GetBookings
func NewGetBookingsRequest(server string, bookingId BookingId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookingId", runtime.ParamLocationPath, bookingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchBookingsRequest generates requests for PatchBookings
func NewPatchBookingsRequest(server string, bookingId BookingId, params *PatchBookingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookingId", runtime.ParamLocationPath, bookingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, params.Status); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Message != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message", runtime.ParamLocationQuery, *params.Message); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDriverJourneysRequest generates requests for GetDriverJourneys
func NewGetDriverJourneysRequest(server string, params *GetDriverJourneysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/driver_journeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLat", runtime.ParamLocationQuery, params.DepartureLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLng", runtime.ParamLocationQuery, params.DepartureLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLat", runtime.ParamLocationQuery, params.ArrivalLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLng", runtime.ParamLocationQuery, params.ArrivalLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureDate", runtime.ParamLocationQuery, params.DepartureDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.TimeDelta != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeDelta", runtime.ParamLocationQuery, *params.TimeDelta); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DepartureRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureRadius", runtime.ParamLocationQuery, *params.DepartureRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ArrivalRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalRadius", runtime.ParamLocationQuery, *params.ArrivalRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDriverRegularTripsRequest generates requests for GetDriverRegularTrips
func NewGetDriverRegularTripsRequest(server string, params *GetDriverRegularTripsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/driver_regular_trips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLat", runtime.ParamLocationQuery, params.DepartureLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLng", runtime.ParamLocationQuery, params.DepartureLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLat", runtime.ParamLocationQuery, params.ArrivalLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLng", runtime.ParamLocationQuery, params.ArrivalLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureTimeOfDay", runtime.ParamLocationQuery, params.DepartureTimeOfDay); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.DepartureWeekdays != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "departureWeekdays", runtime.ParamLocationQuery, *params.DepartureWeekdays); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TimeDelta != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeDelta", runtime.ParamLocationQuery, *params.TimeDelta); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DepartureRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureRadius", runtime.ParamLocationQuery, *params.DepartureRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ArrivalRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalRadius", runtime.ParamLocationQuery, *params.ArrivalRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MinDepartureDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDepartureDate", runtime.ParamLocationQuery, *params.MinDepartureDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MaxDepartureDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxDepartureDate", runtime.ParamLocationQuery, *params.MaxDepartureDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostConnectionsRequest calls the generic PostConnections builder with application/json body
func NewPostConnectionsRequest(server string, body PostConnectionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostConnectionsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostConnectionsRequestWithBody generates requests for PostConnections with any type of body
func NewPostConnectionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPassengerJourneysRequest generates requests for GetPassengerJourneys
func NewGetPassengerJourneysRequest(server string, params *GetPassengerJourneysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/passenger_journeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLat", runtime.ParamLocationQuery, params.DepartureLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLng", runtime.ParamLocationQuery, params.DepartureLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLat", runtime.ParamLocationQuery, params.ArrivalLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLng", runtime.ParamLocationQuery, params.ArrivalLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureDate", runtime.ParamLocationQuery, params.DepartureDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.TimeDelta != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeDelta", runtime.ParamLocationQuery, *params.TimeDelta); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DepartureRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureRadius", runtime.ParamLocationQuery, *params.DepartureRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ArrivalRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalRadius", runtime.ParamLocationQuery, *params.ArrivalRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPassengerRegularTripsRequest generates requests for GetPassengerRegularTrips
func NewGetPassengerRegularTripsRequest(server string, params *GetPassengerRegularTripsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/passenger_regular_trips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLat", runtime.ParamLocationQuery, params.DepartureLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLng", runtime.ParamLocationQuery, params.DepartureLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLat", runtime.ParamLocationQuery, params.ArrivalLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLng", runtime.ParamLocationQuery, params.ArrivalLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureTimeOfDay", runtime.ParamLocationQuery, params.DepartureTimeOfDay); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.DepartureWeekdays != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "departureWeekdays", runtime.ParamLocationQuery, *params.DepartureWeekdays); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TimeDelta != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeDelta", runtime.ParamLocationQuery, *params.TimeDelta); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DepartureRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureRadius", runtime.ParamLocationQuery, *params.DepartureRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ArrivalRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalRadius", runtime.ParamLocationQuery, *params.ArrivalRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MinDepartureDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDepartureDate", runtime.ParamLocationQuery, *params.MinDepartureDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MaxDepartureDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxDepartureDate", runtime.ParamLocationQuery, *params.MaxDepartureDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostBookingEvents request with any body
	PostBookingEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBookingEventsResponse, error)

	PostBookingEventsWithResponse(ctx context.Context, body PostBookingEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBookingEventsResponse, error)

	// PostBookings request with any body
	PostBookingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBookingsResponse, error)

	PostBookingsWithResponse(ctx context.Context, body PostBookingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBookingsResponse, error)

	// GetBookings request
	GetBookingsWithResponse(ctx context.Context, bookingId BookingId, reqEditors ...RequestEditorFn) (*GetBookingsResponse, error)

	// PatchBookings request
	PatchBookingsWithResponse(ctx context.Context, bookingId BookingId, params *PatchBookingsParams, reqEditors ...RequestEditorFn) (*PatchBookingsResponse, error)

	// GetDriverJourneys request
	GetDriverJourneysWithResponse(ctx context.Context, params *GetDriverJourneysParams, reqEditors ...RequestEditorFn) (*GetDriverJourneysResponse, error)

	// GetDriverRegularTrips request
	GetDriverRegularTripsWithResponse(ctx context.Context, params *GetDriverRegularTripsParams, reqEditors ...RequestEditorFn) (*GetDriverRegularTripsResponse, error)

	// PostConnections request with any body
	PostConnectionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostConnectionsResponse, error)

	PostConnectionsWithResponse(ctx context.Context, body PostConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostConnectionsResponse, error)

	// GetPassengerJourneys request
	GetPassengerJourneysWithResponse(ctx context.Context, params *GetPassengerJourneysParams, reqEditors ...RequestEditorFn) (*GetPassengerJourneysResponse, error)

	// GetPassengerRegularTrips request
	GetPassengerRegularTripsWithResponse(ctx context.Context, params *GetPassengerRegularTripsParams, reqEditors ...RequestEditorFn) (*GetPassengerRegularTripsResponse, error)

	// GetStatus request
	GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error)
}

type PostBookingEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		// Error Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostBookingEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBookingEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBookingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Booking
	JSON400      *struct {
		// Error Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostBookingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBookingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBookingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Booking
	JSON400      *struct {
		// Error Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
	JSON404 *struct {
		// Error Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBookingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBookingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchBookingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		// Error Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
	JSON404 *struct {
		// Error Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
	JSON409 *struct {
		// Error Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PatchBookingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchBookingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDriverJourneysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DriverJourney
	JSON400      *struct {
		// Error Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDriverJourneysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDriverJourneysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDriverRegularTripsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Embedded struct due to allOf(#/components/schemas/DriverTrip)
		DriverTrip `yaml:",inline"`
		// Embedded fields due to inline allOf schema
		Schedules *[]Schedule `json:"schedules,omitempty"`
	}
	JSON400 *struct {
		// Error Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDriverRegularTripsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDriverRegularTripsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		// Error Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPassengerJourneysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PassengerJourney
	JSON400      *struct {
		// Error Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPassengerJourneysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPassengerJourneysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPassengerRegularTripsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Embedded struct due to allOf(#/components/schemas/PassengerTrip)
		PassengerTrip `yaml:",inline"`
		// Embedded fields due to inline allOf schema
		Schedules *[]Schedule `json:"schedules,omitempty"`
	}
	JSON400 *struct {
		// Error Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPassengerRegularTripsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPassengerRegularTripsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostBookingEventsWithBodyWithResponse request with arbitrary body returning *PostBookingEventsResponse
func (c *ClientWithResponses) PostBookingEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBookingEventsResponse, error) {
	rsp, err := c.PostBookingEventsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBookingEventsResponse(rsp)
}

func (c *ClientWithResponses) PostBookingEventsWithResponse(ctx context.Context, body PostBookingEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBookingEventsResponse, error) {
	rsp, err := c.PostBookingEvents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBookingEventsResponse(rsp)
}

// PostBookingsWithBodyWithResponse request with arbitrary body returning *PostBookingsResponse
func (c *ClientWithResponses) PostBookingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBookingsResponse, error) {
	rsp, err := c.PostBookingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBookingsResponse(rsp)
}

func (c *ClientWithResponses) PostBookingsWithResponse(ctx context.Context, body PostBookingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBookingsResponse, error) {
	rsp, err := c.PostBookings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBookingsResponse(rsp)
}

// GetBookingsWithResponse request returning *GetBookingsResponse
func (c *ClientWithResponses) GetBookingsWithResponse(ctx context.Context, bookingId BookingId, reqEditors ...RequestEditorFn) (*GetBookingsResponse, error) {
	rsp, err := c.GetBookings(ctx, bookingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBookingsResponse(rsp)
}

// PatchBookingsWithResponse request returning *PatchBookingsResponse
func (c *ClientWithResponses) PatchBookingsWithResponse(ctx context.Context, bookingId BookingId, params *PatchBookingsParams, reqEditors ...RequestEditorFn) (*PatchBookingsResponse, error) {
	rsp, err := c.PatchBookings(ctx, bookingId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchBookingsResponse(rsp)
}

// GetDriverJourneysWithResponse request returning *GetDriverJourneysResponse
func (c *ClientWithResponses) GetDriverJourneysWithResponse(ctx context.Context, params *GetDriverJourneysParams, reqEditors ...RequestEditorFn) (*GetDriverJourneysResponse, error) {
	rsp, err := c.GetDriverJourneys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDriverJourneysResponse(rsp)
}

// GetDriverRegularTripsWithResponse request returning *GetDriverRegularTripsResponse
func (c *ClientWithResponses) GetDriverRegularTripsWithResponse(ctx context.Context, params *GetDriverRegularTripsParams, reqEditors ...RequestEditorFn) (*GetDriverRegularTripsResponse, error) {
	rsp, err := c.GetDriverRegularTrips(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDriverRegularTripsResponse(rsp)
}

// PostConnectionsWithBodyWithResponse request with arbitrary body returning *PostConnectionsResponse
func (c *ClientWithResponses) PostConnectionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostConnectionsResponse, error) {
	rsp, err := c.PostConnectionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostConnectionsResponse(rsp)
}

func (c *ClientWithResponses) PostConnectionsWithResponse(ctx context.Context, body PostConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostConnectionsResponse, error) {
	rsp, err := c.PostConnections(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostConnectionsResponse(rsp)
}

// GetPassengerJourneysWithResponse request returning *GetPassengerJourneysResponse
func (c *ClientWithResponses) GetPassengerJourneysWithResponse(ctx context.Context, params *GetPassengerJourneysParams, reqEditors ...RequestEditorFn) (*GetPassengerJourneysResponse, error) {
	rsp, err := c.GetPassengerJourneys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPassengerJourneysResponse(rsp)
}

// GetPassengerRegularTripsWithResponse request returning *GetPassengerRegularTripsResponse
func (c *ClientWithResponses) GetPassengerRegularTripsWithResponse(ctx context.Context, params *GetPassengerRegularTripsParams, reqEditors ...RequestEditorFn) (*GetPassengerRegularTripsResponse, error) {
	rsp, err := c.GetPassengerRegularTrips(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPassengerRegularTripsResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error) {
	rsp, err := c.GetStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// ParsePostBookingEventsResponse parses an HTTP response from a PostBookingEventsWithResponse call
func ParsePostBookingEventsResponse(rsp *http.Response) (*PostBookingEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBookingEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostBookingsResponse parses an HTTP response from a PostBookingsWithResponse call
func ParsePostBookingsResponse(rsp *http.Response) (*PostBookingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBookingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Booking
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBookingsResponse parses an HTTP response from a GetBookingsWithResponse call
func ParseGetBookingsResponse(rsp *http.Response) (*GetBookingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBookingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Booking
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchBookingsResponse parses an HTTP response from a PatchBookingsWithResponse call
func ParsePatchBookingsResponse(rsp *http.Response) (*PatchBookingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchBookingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			// Error Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetDriverJourneysResponse parses an HTTP response from a GetDriverJourneysWithResponse call
func ParseGetDriverJourneysResponse(rsp *http.Response) (*GetDriverJourneysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDriverJourneysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DriverJourney
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetDriverRegularTripsResponse parses an HTTP response from a GetDriverRegularTripsWithResponse call
func ParseGetDriverRegularTripsResponse(rsp *http.Response) (*GetDriverRegularTripsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDriverRegularTripsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Embedded struct due to allOf(#/components/schemas/DriverTrip)
			DriverTrip `yaml:",inline"`
			// Embedded fields due to inline allOf schema
			Schedules *[]Schedule `json:"schedules,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostConnectionsResponse parses an HTTP response from a PostConnectionsWithResponse call
func ParsePostConnectionsResponse(rsp *http.Response) (*PostConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPassengerJourneysResponse parses an HTTP response from a GetPassengerJourneysWithResponse call
func ParseGetPassengerJourneysResponse(rsp *http.Response) (*GetPassengerJourneysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPassengerJourneysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PassengerJourney
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPassengerRegularTripsResponse parses an HTTP response from a GetPassengerRegularTripsWithResponse call
func ParseGetPassengerRegularTripsResponse(rsp *http.Response) (*GetPassengerRegularTripsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPassengerRegularTripsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Embedded struct due to allOf(#/components/schemas/PassengerTrip)
			PassengerTrip `yaml:",inline"`
			// Embedded fields due to inline allOf schema
			Schedules *[]Schedule `json:"schedules,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Sends booking information of a user connected with a third-party provider back to the provider.
	// (POST /booking_events)
	PostBookingEvents(ctx echo.Context) error
	// Create a punctual outward Booking request.
	// (POST /bookings)
	PostBookings(ctx echo.Context) error
	// Retrieves an existing Booking request.
	// (GET /bookings/{bookingId})
	GetBookings(ctx echo.Context, bookingId BookingId) error
	// Updates status of an existing Booking request.
	// (PATCH /bookings/{bookingId})
	PatchBookings(ctx echo.Context, bookingId BookingId, params PatchBookingsParams) error
	// Search for matching punctual planned outward driver journeys.
	// (GET /driver_journeys)
	GetDriverJourneys(ctx echo.Context, params GetDriverJourneysParams) error
	// Search for matching regular driver trips.
	// (GET /driver_regular_trips)
	GetDriverRegularTrips(ctx echo.Context, params GetDriverRegularTripsParams) error
	// Send a message to the owner of a retrieved journey.
	// (POST /messages)
	PostConnections(ctx echo.Context) error
	// Search for matching punctual planned outward passenger journeys.
	// (GET /passenger_journeys)
	GetPassengerJourneys(ctx echo.Context, params GetPassengerJourneysParams) error
	// Search for matching passenger regular trips.
	// (GET /passenger_regular_trips)
	GetPassengerRegularTrips(ctx echo.Context, params GetPassengerRegularTripsParams) error
	// Give health status of the webservice.
	// (GET /status)
	GetStatus(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostBookingEvents converts echo context to params.
func (w *ServerInterfaceWrapper) PostBookingEvents(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostBookingEvents(ctx)
	return err
}

// PostBookings converts echo context to params.
func (w *ServerInterfaceWrapper) PostBookings(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostBookings(ctx)
	return err
}

// GetBookings converts echo context to params.
func (w *ServerInterfaceWrapper) GetBookings(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bookingId" -------------
	var bookingId BookingId

	err = runtime.BindStyledParameterWithLocation("simple", false, "bookingId", runtime.ParamLocationPath, ctx.Param("bookingId"), &bookingId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bookingId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBookings(ctx, bookingId)
	return err
}

// PatchBookings converts echo context to params.
func (w *ServerInterfaceWrapper) PatchBookings(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bookingId" -------------
	var bookingId BookingId

	err = runtime.BindStyledParameterWithLocation("simple", false, "bookingId", runtime.ParamLocationPath, ctx.Param("bookingId"), &bookingId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bookingId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchBookingsParams
	// ------------- Required query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, true, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "message" -------------

	err = runtime.BindQueryParameter("form", true, false, "message", ctx.QueryParams(), &params.Message)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter message: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchBookings(ctx, bookingId, params)
	return err
}

// GetDriverJourneys converts echo context to params.
func (w *ServerInterfaceWrapper) GetDriverJourneys(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDriverJourneysParams
	// ------------- Required query parameter "departureLat" -------------

	err = runtime.BindQueryParameter("form", true, true, "departureLat", ctx.QueryParams(), &params.DepartureLat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureLat: %s", err))
	}

	// ------------- Required query parameter "departureLng" -------------

	err = runtime.BindQueryParameter("form", true, true, "departureLng", ctx.QueryParams(), &params.DepartureLng)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureLng: %s", err))
	}

	// ------------- Required query parameter "arrivalLat" -------------

	err = runtime.BindQueryParameter("form", true, true, "arrivalLat", ctx.QueryParams(), &params.ArrivalLat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrivalLat: %s", err))
	}

	// ------------- Required query parameter "arrivalLng" -------------

	err = runtime.BindQueryParameter("form", true, true, "arrivalLng", ctx.QueryParams(), &params.ArrivalLng)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrivalLng: %s", err))
	}

	// ------------- Required query parameter "departureDate" -------------

	err = runtime.BindQueryParameter("form", true, true, "departureDate", ctx.QueryParams(), &params.DepartureDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureDate: %s", err))
	}

	// ------------- Optional query parameter "timeDelta" -------------

	err = runtime.BindQueryParameter("form", true, false, "timeDelta", ctx.QueryParams(), &params.TimeDelta)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeDelta: %s", err))
	}

	// ------------- Optional query parameter "departureRadius" -------------

	err = runtime.BindQueryParameter("form", true, false, "departureRadius", ctx.QueryParams(), &params.DepartureRadius)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureRadius: %s", err))
	}

	// ------------- Optional query parameter "arrivalRadius" -------------

	err = runtime.BindQueryParameter("form", true, false, "arrivalRadius", ctx.QueryParams(), &params.ArrivalRadius)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrivalRadius: %s", err))
	}

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDriverJourneys(ctx, params)
	return err
}

// GetDriverRegularTrips converts echo context to params.
func (w *ServerInterfaceWrapper) GetDriverRegularTrips(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDriverRegularTripsParams
	// ------------- Required query parameter "departureLat" -------------

	err = runtime.BindQueryParameter("form", true, true, "departureLat", ctx.QueryParams(), &params.DepartureLat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureLat: %s", err))
	}

	// ------------- Required query parameter "departureLng" -------------

	err = runtime.BindQueryParameter("form", true, true, "departureLng", ctx.QueryParams(), &params.DepartureLng)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureLng: %s", err))
	}

	// ------------- Required query parameter "arrivalLat" -------------

	err = runtime.BindQueryParameter("form", true, true, "arrivalLat", ctx.QueryParams(), &params.ArrivalLat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrivalLat: %s", err))
	}

	// ------------- Required query parameter "arrivalLng" -------------

	err = runtime.BindQueryParameter("form", true, true, "arrivalLng", ctx.QueryParams(), &params.ArrivalLng)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrivalLng: %s", err))
	}

	// ------------- Required query parameter "departureTimeOfDay" -------------

	err = runtime.BindQueryParameter("form", true, true, "departureTimeOfDay", ctx.QueryParams(), &params.DepartureTimeOfDay)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureTimeOfDay: %s", err))
	}

	// ------------- Optional query parameter "departureWeekdays" -------------

	err = runtime.BindQueryParameter("form", false, false, "departureWeekdays", ctx.QueryParams(), &params.DepartureWeekdays)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureWeekdays: %s", err))
	}

	// ------------- Optional query parameter "timeDelta" -------------

	err = runtime.BindQueryParameter("form", true, false, "timeDelta", ctx.QueryParams(), &params.TimeDelta)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeDelta: %s", err))
	}

	// ------------- Optional query parameter "departureRadius" -------------

	err = runtime.BindQueryParameter("form", true, false, "departureRadius", ctx.QueryParams(), &params.DepartureRadius)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureRadius: %s", err))
	}

	// ------------- Optional query parameter "arrivalRadius" -------------

	err = runtime.BindQueryParameter("form", true, false, "arrivalRadius", ctx.QueryParams(), &params.ArrivalRadius)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrivalRadius: %s", err))
	}

	// ------------- Optional query parameter "minDepartureDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "minDepartureDate", ctx.QueryParams(), &params.MinDepartureDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minDepartureDate: %s", err))
	}

	// ------------- Optional query parameter "maxDepartureDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxDepartureDate", ctx.QueryParams(), &params.MaxDepartureDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxDepartureDate: %s", err))
	}

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDriverRegularTrips(ctx, params)
	return err
}

// PostConnections converts echo context to params.
func (w *ServerInterfaceWrapper) PostConnections(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostConnections(ctx)
	return err
}

// GetPassengerJourneys converts echo context to params.
func (w *ServerInterfaceWrapper) GetPassengerJourneys(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPassengerJourneysParams
	// ------------- Required query parameter "departureLat" -------------

	err = runtime.BindQueryParameter("form", true, true, "departureLat", ctx.QueryParams(), &params.DepartureLat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureLat: %s", err))
	}

	// ------------- Required query parameter "departureLng" -------------

	err = runtime.BindQueryParameter("form", true, true, "departureLng", ctx.QueryParams(), &params.DepartureLng)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureLng: %s", err))
	}

	// ------------- Required query parameter "arrivalLat" -------------

	err = runtime.BindQueryParameter("form", true, true, "arrivalLat", ctx.QueryParams(), &params.ArrivalLat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrivalLat: %s", err))
	}

	// ------------- Required query parameter "arrivalLng" -------------

	err = runtime.BindQueryParameter("form", true, true, "arrivalLng", ctx.QueryParams(), &params.ArrivalLng)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrivalLng: %s", err))
	}

	// ------------- Required query parameter "departureDate" -------------

	err = runtime.BindQueryParameter("form", true, true, "departureDate", ctx.QueryParams(), &params.DepartureDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureDate: %s", err))
	}

	// ------------- Optional query parameter "timeDelta" -------------

	err = runtime.BindQueryParameter("form", true, false, "timeDelta", ctx.QueryParams(), &params.TimeDelta)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeDelta: %s", err))
	}

	// ------------- Optional query parameter "departureRadius" -------------

	err = runtime.BindQueryParameter("form", true, false, "departureRadius", ctx.QueryParams(), &params.DepartureRadius)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureRadius: %s", err))
	}

	// ------------- Optional query parameter "arrivalRadius" -------------

	err = runtime.BindQueryParameter("form", true, false, "arrivalRadius", ctx.QueryParams(), &params.ArrivalRadius)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrivalRadius: %s", err))
	}

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPassengerJourneys(ctx, params)
	return err
}

// GetPassengerRegularTrips converts echo context to params.
func (w *ServerInterfaceWrapper) GetPassengerRegularTrips(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPassengerRegularTripsParams
	// ------------- Required query parameter "departureLat" -------------

	err = runtime.BindQueryParameter("form", true, true, "departureLat", ctx.QueryParams(), &params.DepartureLat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureLat: %s", err))
	}

	// ------------- Required query parameter "departureLng" -------------

	err = runtime.BindQueryParameter("form", true, true, "departureLng", ctx.QueryParams(), &params.DepartureLng)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureLng: %s", err))
	}

	// ------------- Required query parameter "arrivalLat" -------------

	err = runtime.BindQueryParameter("form", true, true, "arrivalLat", ctx.QueryParams(), &params.ArrivalLat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrivalLat: %s", err))
	}

	// ------------- Required query parameter "arrivalLng" -------------

	err = runtime.BindQueryParameter("form", true, true, "arrivalLng", ctx.QueryParams(), &params.ArrivalLng)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrivalLng: %s", err))
	}

	// ------------- Required query parameter "departureTimeOfDay" -------------

	err = runtime.BindQueryParameter("form", true, true, "departureTimeOfDay", ctx.QueryParams(), &params.DepartureTimeOfDay)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureTimeOfDay: %s", err))
	}

	// ------------- Optional query parameter "departureWeekdays" -------------

	err = runtime.BindQueryParameter("form", false, false, "departureWeekdays", ctx.QueryParams(), &params.DepartureWeekdays)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureWeekdays: %s", err))
	}

	// ------------- Optional query parameter "timeDelta" -------------

	err = runtime.BindQueryParameter("form", true, false, "timeDelta", ctx.QueryParams(), &params.TimeDelta)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeDelta: %s", err))
	}

	// ------------- Optional query parameter "departureRadius" -------------

	err = runtime.BindQueryParameter("form", true, false, "departureRadius", ctx.QueryParams(), &params.DepartureRadius)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter departureRadius: %s", err))
	}

	// ------------- Optional query parameter "arrivalRadius" -------------

	err = runtime.BindQueryParameter("form", true, false, "arrivalRadius", ctx.QueryParams(), &params.ArrivalRadius)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrivalRadius: %s", err))
	}

	// ------------- Optional query parameter "minDepartureDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "minDepartureDate", ctx.QueryParams(), &params.MinDepartureDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minDepartureDate: %s", err))
	}

	// ------------- Optional query parameter "maxDepartureDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxDepartureDate", ctx.QueryParams(), &params.MaxDepartureDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxDepartureDate: %s", err))
	}

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPassengerRegularTrips(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/booking_events", wrapper.PostBookingEvents)
	router.POST(baseURL+"/bookings", wrapper.PostBookings)
	router.GET(baseURL+"/bookings/:bookingId", wrapper.GetBookings)
	router.PATCH(baseURL+"/bookings/:bookingId", wrapper.PatchBookings)
	router.GET(baseURL+"/driver_journeys", wrapper.GetDriverJourneys)
	router.GET(baseURL+"/driver_regular_trips", wrapper.GetDriverRegularTrips)
	router.POST(baseURL+"/messages", wrapper.PostConnections)
	router.GET(baseURL+"/passenger_journeys", wrapper.GetPassengerJourneys)
	router.GET(baseURL+"/passenger_regular_trips", wrapper.GetPassengerRegularTrips)
	router.GET(baseURL+"/status", wrapper.GetStatus)

}
