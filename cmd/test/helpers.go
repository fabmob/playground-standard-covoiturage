package test

import (
	"bytes"
	"io"
)

/////////////////////////////////////////////////////////////
// Query parameter extraction
/////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////
// Response body extraction
/////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////

type reusableReadCloser struct {
	io.ReadCloser
	readBuf *bytes.Buffer
	backBuf *bytes.Buffer
}

// ReusableReadCloser wraps a io.ReadCloser so that it can be read and closed as
// many times as needed
func ReusableReadCloser(r io.ReadCloser) (io.ReadCloser, error) {
	var readBuf = bytes.Buffer{}

	_, err := readBuf.ReadFrom(r)
	if err != nil {
		return nil, err
	}

	backBuf := bytes.Buffer{}

	return reusableReadCloser{
		io.NopCloser(io.TeeReader(&readBuf, &backBuf)),
		&readBuf,
		&backBuf,
	}, nil
}

func (r reusableReadCloser) Read(p []byte) (int, error) {
	n, err := r.ReadCloser.Read(p)
	if err == io.EOF {
		r.reset()
	}

	return n, err
}

func (r reusableReadCloser) reset() {
	io.Copy(r.readBuf, r.backBuf) // nolint: errcheck
}

func (r reusableReadCloser) Close() error {
	return nil
}

/////////////////////////////////////////////////////////////
