// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

// Defines values for CarpoolBookingStatus.
const (
	CarpoolBookingStatusCANCELLED                  CarpoolBookingStatus = "CANCELLED"
	CarpoolBookingStatusCOMPLETEDPENDINGVALIDATION CarpoolBookingStatus = "COMPLETED_PENDING_VALIDATION"
	CarpoolBookingStatusCONFIRMED                  CarpoolBookingStatus = "CONFIRMED"
	CarpoolBookingStatusVALIDATED                  CarpoolBookingStatus = "VALIDATED"
	CarpoolBookingStatusWAITINGCONFIRMATION        CarpoolBookingStatus = "WAITING_CONFIRMATION"
)

// Defines values for DriverCarpoolBookingStatus.
const (
	DriverCarpoolBookingStatusCANCELLED                  DriverCarpoolBookingStatus = "CANCELLED"
	DriverCarpoolBookingStatusCOMPLETEDPENDINGVALIDATION DriverCarpoolBookingStatus = "COMPLETED_PENDING_VALIDATION"
	DriverCarpoolBookingStatusCONFIRMED                  DriverCarpoolBookingStatus = "CONFIRMED"
	DriverCarpoolBookingStatusVALIDATED                  DriverCarpoolBookingStatus = "VALIDATED"
	DriverCarpoolBookingStatusWAITINGCONFIRMATION        DriverCarpoolBookingStatus = "WAITING_CONFIRMATION"
)

// Defines values for DriverJourneyType.
const (
	DriverJourneyTypeDYNAMIC DriverJourneyType = "DYNAMIC"
	DriverJourneyTypeLINE    DriverJourneyType = "LINE"
	DriverJourneyTypePLANNED DriverJourneyType = "PLANNED"
)

// Defines values for JourneyScheduleType.
const (
	JourneyScheduleTypeDYNAMIC JourneyScheduleType = "DYNAMIC"
	JourneyScheduleTypeLINE    JourneyScheduleType = "LINE"
	JourneyScheduleTypePLANNED JourneyScheduleType = "PLANNED"
)

// Defines values for PassengerCarpoolBookingStatus.
const (
	PassengerCarpoolBookingStatusCANCELLED                  PassengerCarpoolBookingStatus = "CANCELLED"
	PassengerCarpoolBookingStatusCOMPLETEDPENDINGVALIDATION PassengerCarpoolBookingStatus = "COMPLETED_PENDING_VALIDATION"
	PassengerCarpoolBookingStatusCONFIRMED                  PassengerCarpoolBookingStatus = "CONFIRMED"
	PassengerCarpoolBookingStatusVALIDATED                  PassengerCarpoolBookingStatus = "VALIDATED"
	PassengerCarpoolBookingStatusWAITINGCONFIRMATION        PassengerCarpoolBookingStatus = "WAITING_CONFIRMATION"
)

// Defines values for PassengerJourneyType.
const (
	DYNAMIC PassengerJourneyType = "DYNAMIC"
	LINE    PassengerJourneyType = "LINE"
	PLANNED PassengerJourneyType = "PLANNED"
)

// Defines values for PriceType.
const (
	FREE    PriceType = "FREE"
	PAYING  PriceType = "PAYING"
	UNKNOWN PriceType = "UNKNOWN"
)

// Defines values for SchedulePassengerPickupDay.
const (
	FRI SchedulePassengerPickupDay = "FRI"
	MON SchedulePassengerPickupDay = "MON"
	SAT SchedulePassengerPickupDay = "SAT"
	SUN SchedulePassengerPickupDay = "SUN"
	THU SchedulePassengerPickupDay = "THU"
	TUE SchedulePassengerPickupDay = "TUE"
	WED SchedulePassengerPickupDay = "WED"
)

// Defines values for UserGender.
const (
	F UserGender = "F"
	M UserGender = "M"
	O UserGender = "O"
)

// Defines values for BookingStatus.
const (
	BookingStatusCANCELLED                  BookingStatus = "CANCELLED"
	BookingStatusCOMPLETEDPENDINGVALIDATION BookingStatus = "COMPLETED_PENDING_VALIDATION"
	BookingStatusCONFIRMED                  BookingStatus = "CONFIRMED"
	BookingStatusVALIDATED                  BookingStatus = "VALIDATED"
	BookingStatusWAITINGCONFIRMATION        BookingStatus = "WAITING_CONFIRMATION"
)

// Booking defines model for Booking.
type Booking struct {
	Car *Car `json:"car,omitempty"`

	// Carpooling distance in meters.
	Distance *int `json:"distance,omitempty"`
	Driver   User `json:"driver"`

	// ID of the Driver's journey to which the booking is related (if any). Unique given the `User`'s `operator` property.
	DriverJourneyId *string `json:"driverJourneyId,omitempty"`

	// Carpooling duration in seconds.
	Duration *int `json:"duration,omitempty"`

	// Booking id is common between both operators, and must be created as a [UUID](https://datatracker.ietf.org/doc/html/rfc4122) by whoever initiates the booking.  Usage of a [4 UUID](https://datatracker.ietf.org/doc/html/rfc4122#section-4.4) generation algorithm is advised.
	Id        BookingId `json:"id"`
	Passenger User      `json:"passenger"`

	// String representing the drop-off address.
	PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

	// Latitude of the passenger drop-off point.
	PassengerDropLat float64 `json:"passengerDropLat"`

	// Longitude of the passenger drop-off point.
	PassengerDropLng float64 `json:"passengerDropLng"`

	// ID of the Passenger's journey to which the booking is related (if any). Unique given the `User`'s `operator` property.
	PassengerJourneyId *string `json:"passengerJourneyId,omitempty"`

	// String representing the pickup-up address.
	PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

	// Passenger pickup datetime as a UNIX UTC timestamp in seconds.
	PassengerPickupDate int64 `json:"passengerPickupDate"`

	// Latitude of the passenger pick-up point.
	PassengerPickupLat float64 `json:"passengerPickupLat"`

	// Longitude of the passenger pick-up point.
	PassengerPickupLng float64 `json:"passengerPickupLng"`
	Price              Price   `json:"price"`

	// Status of the booking.
	Status BookingStatus `json:"status"`

	// URL of the booking on the webservice provider platform.
	WebUrl *string `json:"webUrl,omitempty"`
}

// Car defines model for Car.
type Car struct {
	// Brand of the car.
	Brand *string `json:"brand,omitempty"`

	// Model of the car.
	Model *string `json:"model,omitempty"`
}

// CarpoolBooking defines model for CarpoolBooking.
type CarpoolBooking struct {
	// Carpooling distance in meters. When the booking is COMPLETED or VALIDATED, this is the actual distance travelled if available.
	Distance *int `json:"distance,omitempty"`

	// Carpooling duration in seconds.
	Duration *int `json:"duration,omitempty"`

	// Unique identifier of the booking.
	Id string `json:"id"`

	// String representing the drop-off address.
	PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

	// Latitude of the passenger drop-off point.
	PassengerDropLat float64 `json:"passengerDropLat"`

	// Longitude of the passenger drop-off point.
	PassengerDropLng float64 `json:"passengerDropLng"`

	// String representing the pickup-up address.
	PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

	// Passenger pickup datetime as a UNIX UTC timestamp in seconds.
	PassengerPickupDate int64 `json:"passengerPickupDate"`

	// Latitude of the passenger pick-up point.
	PassengerPickupLat float64 `json:"passengerPickupLat"`

	// Longitude of the passenger pick-up point.
	PassengerPickupLng float64              `json:"passengerPickupLng"`
	Status             CarpoolBookingStatus `json:"status"`

	// URL of the booking on the webservice provider platform.
	WebUrl string `json:"webUrl"`
}

// CarpoolBookingStatus defines model for CarpoolBooking.Status.
type CarpoolBookingStatus string

// CarpoolBookingEvent defines model for CarpoolBookingEvent.
type CarpoolBookingEvent struct {
	Data interface{} `json:"data"`

	// Unique journey's id in the format of an [UUID](https://datatracker.ietf.org/doc/html/rfc4122). Usage of a [4 UUID](https://datatracker.ietf.org/doc/html/rfc4122#section-4.4) generation algorithm is advised.
	Id openapi_types.UUID `json:"id"`

	// ID token of the user retrieved using the OpenID Connect flows.
	IdToken string `json:"idToken"`
}

// DriverCarpoolBooking defines model for DriverCarpoolBooking.
type DriverCarpoolBooking struct {
	Car *Car `json:"car,omitempty"`

	// Carpooling distance in meters. When the booking is COMPLETED or VALIDATED, this is the actual distance travelled if available.
	Distance *int `json:"distance,omitempty"`
	Driver   User `json:"driver"`

	// Carpooling duration in seconds.
	Duration *int `json:"duration,omitempty"`

	// Unique identifier of the booking.
	Id string `json:"id"`

	// String representing the drop-off address.
	PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

	// Latitude of the passenger drop-off point.
	PassengerDropLat float64 `json:"passengerDropLat"`

	// Longitude of the passenger drop-off point.
	PassengerDropLng float64 `json:"passengerDropLng"`

	// String representing the pickup-up address.
	PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

	// Passenger pickup datetime as a UNIX UTC timestamp in seconds.
	PassengerPickupDate int64 `json:"passengerPickupDate"`

	// Latitude of the passenger pick-up point.
	PassengerPickupLat float64 `json:"passengerPickupLat"`

	// Longitude of the passenger pick-up point.
	PassengerPickupLng float64                    `json:"passengerPickupLng"`
	Price              Price                      `json:"price"`
	Status             DriverCarpoolBookingStatus `json:"status"`

	// URL of the booking on the webservice provider platform.
	WebUrl string `json:"webUrl"`
}

// DriverCarpoolBookingStatus defines model for DriverCarpoolBooking.Status.
type DriverCarpoolBookingStatus string

// DriverJourney defines model for DriverJourney.
type DriverJourney struct {
	// Available seats in the car.
	AvailableSeats *int `json:"availableSeats,omitempty"`
	Car            *Car `json:"car,omitempty"`

	// Walking distance from the requested departure location
	// to the pick-up location.
	DepartureToPickupWalkingDistance *int `json:"departureToPickupWalkingDistance,omitempty"`

	// Walking duration from the requested departure location
	// to the pick-up location.
	DepartureToPickupWalkingDuration *int `json:"departureToPickupWalkingDuration,omitempty"`

	// Walking
	// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
	// from the requested departure location to the pick-up location.
	DepartureToPickupWalkingPolyline *string `json:"departureToPickupWalkingPolyline,omitempty"`

	// Carpooling distance in meters.
	Distance *int `json:"distance,omitempty"`
	Driver   User `json:"driver"`

	// String representing the arrival address of the driver.
	DriverArrivalAddress *string `json:"driverArrivalAddress,omitempty"`

	// Latitude of the arrival.
	DriverArrivalLat *float64 `json:"driverArrivalLat,omitempty"`

	// Longitude of the arrival.
	DriverArrivalLng *float64 `json:"driverArrivalLng,omitempty"`

	// String representing the departure address of the driver.
	DriverDepartureAddress *string `json:"driverDepartureAddress,omitempty"`

	// Driver departure datetime as a UNIX UTC timestamp in seconds.
	DriverDepartureDate *int64 `json:"driverDepartureDate,omitempty"`

	// Latitude of the departure.
	DriverDepartureLat *float64 `json:"driverDepartureLat,omitempty"`

	// Longitude of the departure.
	DriverDepartureLng *float64 `json:"driverDepartureLng,omitempty"`

	// Walking distance to the requested arrival location
	// from the drop-off location.
	DropoffToArrivalWalkingDistance *int `json:"dropoffToArrivalWalkingDistance,omitempty"`

	// Walking duration to the requested arrival location
	// from the drop-off location.
	DropoffToArrivalWalkingDuration *int `json:"dropoffToArrivalWalkingDuration,omitempty"`

	// Walking
	// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
	// to the requested arrival location from the drop-off location.
	DropoffToArrivalWalkingPolyline *string `json:"dropoffToArrivalWalkingPolyline,omitempty"`

	// Carpooling duration in seconds.
	Duration int `json:"duration"`

	// Journey's id. It MUST be unique for a given operator.
	Id *string `json:"id,omitempty"`

	// Carpooling journey itinerary as a
	// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm), compressed at  level 5.
	JourneyPolyline *string `json:"journeyPolyline,omitempty"`

	// The operator identifier. MUST be a Root Domain (example operator.org) owned by the operator or a Fully Qualified Domain Name (example carpool.mycity.com) exclusively operated by the operator. A given operator SHOULD always send the same value.
	Operator string `json:"operator"`

	// String representing the drop-off address.
	PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

	// Latitude of the passenger drop-off point.
	PassengerDropLat float64 `json:"passengerDropLat"`

	// Longitude of the passenger drop-off point.
	PassengerDropLng float64 `json:"passengerDropLng"`

	// String representing the pickup-up address.
	PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

	// Passenger pickup datetime as a UNIX UTC timestamp in seconds.
	PassengerPickupDate int64 `json:"passengerPickupDate"`

	// Latitude of the passenger pick-up point.
	PassengerPickupLat float64 `json:"passengerPickupLat"`

	// Longitude of the passenger pick-up point.
	PassengerPickupLng float64      `json:"passengerPickupLng"`
	Preferences        *Preferences `json:"preferences,omitempty"`
	Price              *Price       `json:"price,omitempty"`

	// Type of journey. A dynamic journey is happening in real time.
	Type DriverJourneyType `json:"type"`

	// URL of the journey on the webservice provider platform. Required to support booking by deeplink.
	WebUrl *string `json:"webUrl,omitempty"`
}

// Type of journey. A dynamic journey is happening in real time.
type DriverJourneyType string

// DriverTrip defines model for DriverTrip.
type DriverTrip struct {
	Car *Car `json:"car,omitempty"`

	// Walking distance from the requested departure location
	// to the pick-up location.
	DepartureToPickupWalkingDistance *int `json:"departureToPickupWalkingDistance,omitempty"`

	// Walking duration from the requested departure location
	// to the pick-up location.
	DepartureToPickupWalkingDuration *int `json:"departureToPickupWalkingDuration,omitempty"`

	// Walking
	// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
	// from the requested departure location to the pick-up location.
	DepartureToPickupWalkingPolyline *string `json:"departureToPickupWalkingPolyline,omitempty"`

	// Carpooling distance in meters.
	Distance *int `json:"distance,omitempty"`
	Driver   User `json:"driver"`

	// String representing the arrival address of the driver.
	DriverArrivalAddress *string `json:"driverArrivalAddress,omitempty"`

	// Latitude of the arrival.
	DriverArrivalLat *float64 `json:"driverArrivalLat,omitempty"`

	// Longitude of the arrival.
	DriverArrivalLng *float64 `json:"driverArrivalLng,omitempty"`

	// String representing the departure address of the driver.
	DriverDepartureAddress *string `json:"driverDepartureAddress,omitempty"`

	// Latitude of the departure.
	DriverDepartureLat *float64 `json:"driverDepartureLat,omitempty"`

	// Longitude of the departure.
	DriverDepartureLng *float64 `json:"driverDepartureLng,omitempty"`

	// Walking distance to the requested arrival location
	// from the drop-off location.
	DropoffToArrivalWalkingDistance *int `json:"dropoffToArrivalWalkingDistance,omitempty"`

	// Walking duration to the requested arrival location
	// from the drop-off location.
	DropoffToArrivalWalkingDuration *int `json:"dropoffToArrivalWalkingDuration,omitempty"`

	// Walking
	// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
	// to the requested arrival location from the drop-off location.
	DropoffToArrivalWalkingPolyline *string `json:"dropoffToArrivalWalkingPolyline,omitempty"`

	// Carpooling duration in seconds.
	Duration int `json:"duration"`

	// Carpooling journey itinerary as a
	// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm), compressed at  level 5.
	JourneyPolyline *string `json:"journeyPolyline,omitempty"`

	// The operator identifier. MUST be a Root Domain (example operator.org) owned by the operator or a Fully Qualified Domain Name (example carpool.mycity.com) exclusively operated by the operator. A given operator SHOULD always send the same value.
	Operator string `json:"operator"`

	// String representing the drop-off address.
	PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

	// Latitude of the passenger drop-off point.
	PassengerDropLat float64 `json:"passengerDropLat"`

	// Longitude of the passenger drop-off point.
	PassengerDropLng float64 `json:"passengerDropLng"`

	// String representing the pickup-up address.
	PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

	// Latitude of the passenger pick-up point.
	PassengerPickupLat float64 `json:"passengerPickupLat"`

	// Longitude of the passenger pick-up point.
	PassengerPickupLng float64      `json:"passengerPickupLng"`
	Preferences        *Preferences `json:"preferences,omitempty"`

	// URL of the trip on the webservice provider platform.
	WebUrl *string `json:"webUrl,omitempty"`
}

// JourneySchedule defines model for JourneySchedule.
type JourneySchedule struct {
	// Driver departure datetime as a UNIX UTC timestamp in seconds.
	DriverDepartureDate *int64 `json:"driverDepartureDate,omitempty"`

	// Journey's id. It MUST be unique for a given operator.
	Id *string `json:"id,omitempty"`

	// Passenger pickup datetime as a UNIX UTC timestamp in seconds.
	PassengerPickupDate int64 `json:"passengerPickupDate"`

	// Type of journey. A dynamic journey is happening in real time.
	Type JourneyScheduleType `json:"type"`

	// URL of the journey on the webservice provider platform. Required to support booking by deeplink.
	WebUrl *string `json:"webUrl,omitempty"`
}

// Type of journey. A dynamic journey is happening in real time.
type JourneyScheduleType string

// PassengerCarpoolBooking defines model for PassengerCarpoolBooking.
type PassengerCarpoolBooking struct {
	// Carpooling distance in meters. When the booking is COMPLETED or VALIDATED, this is the actual distance travelled if available.
	Distance *int `json:"distance,omitempty"`

	// Carpooling duration in seconds.
	Duration *int `json:"duration,omitempty"`

	// Unique identifier of the booking.
	Id        string `json:"id"`
	Passenger User   `json:"passenger"`

	// String representing the drop-off address.
	PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

	// Latitude of the passenger drop-off point.
	PassengerDropLat float64 `json:"passengerDropLat"`

	// Longitude of the passenger drop-off point.
	PassengerDropLng float64 `json:"passengerDropLng"`

	// String representing the pickup-up address.
	PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

	// Passenger pickup datetime as a UNIX UTC timestamp in seconds.
	PassengerPickupDate int64 `json:"passengerPickupDate"`

	// Latitude of the passenger pick-up point.
	PassengerPickupLat float64 `json:"passengerPickupLat"`

	// Longitude of the passenger pick-up point.
	PassengerPickupLng float64                       `json:"passengerPickupLng"`
	Status             PassengerCarpoolBookingStatus `json:"status"`

	// URL of the booking on the webservice provider platform.
	WebUrl string `json:"webUrl"`
}

// PassengerCarpoolBookingStatus defines model for PassengerCarpoolBooking.Status.
type PassengerCarpoolBookingStatus string

// PassengerJourney defines model for PassengerJourney.
type PassengerJourney struct {
	// Carpooling distance in meters.
	Distance *int `json:"distance,omitempty"`

	// String representing the arrival address of the driver.
	DriverArrivalAddress *string `json:"driverArrivalAddress,omitempty"`

	// Latitude of the arrival.
	DriverArrivalLat *float64 `json:"driverArrivalLat,omitempty"`

	// Longitude of the arrival.
	DriverArrivalLng *float64 `json:"driverArrivalLng,omitempty"`

	// String representing the departure address of the driver.
	DriverDepartureAddress *string `json:"driverDepartureAddress,omitempty"`

	// Driver departure datetime as a UNIX UTC timestamp in seconds.
	DriverDepartureDate int64 `json:"driverDepartureDate"`

	// Latitude of the departure.
	DriverDepartureLat *float64 `json:"driverDepartureLat,omitempty"`

	// Longitude of the departure.
	DriverDepartureLng *float64 `json:"driverDepartureLng,omitempty"`

	// Carpooling duration in seconds.
	Duration int `json:"duration"`

	// Journey's id. It MUST be unique for a given operator.
	Id *string `json:"id,omitempty"`

	// Carpooling journey itinerary as a
	// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm), compressed at  level 5.
	JourneyPolyline *string `json:"journeyPolyline,omitempty"`

	// The operator identifier. MUST be a Root Domain (example operator.org) owned by the operator or a Fully Qualified Domain Name (example carpool.mycity.com) exclusively operated by the operator. A given operator SHOULD always send the same value.
	Operator  string `json:"operator"`
	Passenger User   `json:"passenger"`

	// String representing the drop-off address.
	PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

	// Latitude of the passenger drop-off point.
	PassengerDropLat float64 `json:"passengerDropLat"`

	// Longitude of the passenger drop-off point.
	PassengerDropLng float64 `json:"passengerDropLng"`

	// String representing the pickup-up address.
	PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

	// Passenger pickup datetime as a UNIX UTC timestamp in seconds.
	PassengerPickupDate int64 `json:"passengerPickupDate"`

	// Latitude of the passenger pick-up point.
	PassengerPickupLat float64 `json:"passengerPickupLat"`

	// Longitude of the passenger pick-up point.
	PassengerPickupLng float64      `json:"passengerPickupLng"`
	Preferences        *Preferences `json:"preferences,omitempty"`

	// Requested seats by the passenger.
	RequestedSeats *int `json:"requestedSeats,omitempty"`

	// Type of journey. A dynamic journey is happening in real time.
	Type PassengerJourneyType `json:"type"`

	// URL of the journey on the webservice provider platform. Required to support booking by deeplink.
	WebUrl *string `json:"webUrl,omitempty"`
}

// Type of journey. A dynamic journey is happening in real time.
type PassengerJourneyType string

// PassengerTrip defines model for PassengerTrip.
type PassengerTrip struct {
	// Carpooling distance in meters.
	Distance *int `json:"distance,omitempty"`

	// String representing the arrival address of the driver.
	DriverArrivalAddress *string `json:"driverArrivalAddress,omitempty"`

	// Latitude of the arrival.
	DriverArrivalLat *float64 `json:"driverArrivalLat,omitempty"`

	// Longitude of the arrival.
	DriverArrivalLng *float64 `json:"driverArrivalLng,omitempty"`

	// String representing the departure address of the driver.
	DriverDepartureAddress *string `json:"driverDepartureAddress,omitempty"`

	// Latitude of the departure.
	DriverDepartureLat *float64 `json:"driverDepartureLat,omitempty"`

	// Longitude of the departure.
	DriverDepartureLng *float64 `json:"driverDepartureLng,omitempty"`

	// Carpooling duration in seconds.
	Duration int `json:"duration"`

	// Carpooling journey itinerary as a
	// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm), compressed at  level 5.
	JourneyPolyline *string `json:"journeyPolyline,omitempty"`

	// The operator identifier. MUST be a Root Domain (example operator.org) owned by the operator or a Fully Qualified Domain Name (example carpool.mycity.com) exclusively operated by the operator. A given operator SHOULD always send the same value.
	Operator  string `json:"operator"`
	Passenger User   `json:"passenger"`

	// String representing the drop-off address.
	PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

	// Latitude of the passenger drop-off point.
	PassengerDropLat float64 `json:"passengerDropLat"`

	// Longitude of the passenger drop-off point.
	PassengerDropLng float64 `json:"passengerDropLng"`

	// String representing the pickup-up address.
	PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

	// Latitude of the passenger pick-up point.
	PassengerPickupLat float64 `json:"passengerPickupLat"`

	// Longitude of the passenger pick-up point.
	PassengerPickupLng float64      `json:"passengerPickupLng"`
	Preferences        *Preferences `json:"preferences,omitempty"`

	// URL of the trip on the webservice provider platform.
	WebUrl *string `json:"webUrl,omitempty"`
}

// Preferences defines model for Preferences.
type Preferences struct {
	// If driver journey, specifies if the driver allows animals in the car.
	Animals *bool `json:"animals,omitempty"`

	// If driver journey, specifies if the driver enjoys talking with passengers.
	IsTalker *bool `json:"isTalker,omitempty"`

	// If driver journey, specifies the size of allowed luggages.
	// From very small (1) to very big (5).
	LuggageSize *int `json:"luggageSize,omitempty"`

	// If driver journey, specifies if the driver enjoys music in the car.
	Music *bool `json:"music,omitempty"`

	// If driver journey, specifies if the driver allows smoking in the car.
	Smoking *bool `json:"smoking,omitempty"`
}

// Price defines model for Price.
type Price struct {
	// Carpooling passenger cost estimate. In the case of integrated booking by API, amount expected by the carpooling operator.
	Amount *float32 `json:"amount,omitempty"`

	// ISO 4217 code representing the currency of the price.
	Currency *string `json:"currency,omitempty"`

	// Either « FREE », « PAYING » or « UNKNOWN ». « UNKNOWN » is given
	// when it should be « PAYING » but we cannot set the price yet.
	Type *PriceType `json:"type,omitempty"`
}

// Either « FREE », « PAYING » or « UNKNOWN ». « UNKNOWN » is given
// when it should be « PAYING » but we cannot set the price yet.
type PriceType string

// Schedule defines model for Schedule.
type Schedule struct {
	JourneySchedules *[]JourneySchedule `json:"journeySchedules,omitempty"`

	// Day of week of the passenger pick-up.
	PassengerPickupDay *SchedulePassengerPickupDay `json:"passengerPickupDay,omitempty"`

	// Passenger pick-up time of day represented as
	// [RFC3339 partial-time](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6).
	PassengerPickupTimeOfDay *string `json:"passengerPickupTimeOfDay,omitempty"`
}

// Day of week of the passenger pick-up.
type SchedulePassengerPickupDay string

// Trip defines model for Trip.
type Trip struct {
	// Carpooling distance in meters.
	Distance *int `json:"distance,omitempty"`

	// String representing the arrival address of the driver.
	DriverArrivalAddress *string `json:"driverArrivalAddress,omitempty"`

	// Latitude of the arrival.
	DriverArrivalLat *float64 `json:"driverArrivalLat,omitempty"`

	// Longitude of the arrival.
	DriverArrivalLng *float64 `json:"driverArrivalLng,omitempty"`

	// String representing the departure address of the driver.
	DriverDepartureAddress *string `json:"driverDepartureAddress,omitempty"`

	// Latitude of the departure.
	DriverDepartureLat *float64 `json:"driverDepartureLat,omitempty"`

	// Longitude of the departure.
	DriverDepartureLng *float64 `json:"driverDepartureLng,omitempty"`

	// Carpooling duration in seconds.
	Duration int `json:"duration"`

	// Carpooling journey itinerary as a
	// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm), compressed at  level 5.
	JourneyPolyline *string `json:"journeyPolyline,omitempty"`

	// The operator identifier. MUST be a Root Domain (example operator.org) owned by the operator or a Fully Qualified Domain Name (example carpool.mycity.com) exclusively operated by the operator. A given operator SHOULD always send the same value.
	Operator string `json:"operator"`

	// String representing the drop-off address.
	PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

	// Latitude of the passenger drop-off point.
	PassengerDropLat float64 `json:"passengerDropLat"`

	// Longitude of the passenger drop-off point.
	PassengerDropLng float64 `json:"passengerDropLng"`

	// String representing the pickup-up address.
	PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

	// Latitude of the passenger pick-up point.
	PassengerPickupLat float64 `json:"passengerPickupLat"`

	// Longitude of the passenger pick-up point.
	PassengerPickupLng float64      `json:"passengerPickupLng"`
	Preferences        *Preferences `json:"preferences,omitempty"`

	// URL of the trip on the webservice provider platform.
	WebUrl *string `json:"webUrl,omitempty"`
}

// User defines model for User.
type User struct {
	// User's alias.
	Alias string `json:"alias"`

	// User's first name.
	FirstName *string `json:"firstName,omitempty"`

	// User's gender. 'O' stands for 'Other'.
	Gender *UserGender `json:"gender,omitempty"`

	// User's grade from 1 to 5.
	Grade *int `json:"grade,omitempty"`

	// User's identifier. It MUST be unique for a given `operator`.
	Id string `json:"id"`

	// User's last name.
	LastName *string `json:"lastName,omitempty"`

	// The operator identifier. MUST be a Fully Qualified Domain Name (example carpool.mycity.com) owned by the operator or a Partially Qualified Domain Name (example operator.org) owned and exclusively operated by the operator. Operators SHOULD always send the same value.
	Operator string `json:"operator"`

	// User's profile picture absolute URL.
	Picture *string `json:"picture,omitempty"`

	// true if the identity of this user has been verified by the operator or a third party; and the firstName, lastName, birthdate have been confirmed as identitical to an official identity proof document. Can be left empty if the information is not available.
	VerifiedIdentity *bool `json:"verifiedIdentity,omitempty"`
}

// User's gender. 'O' stands for 'Other'.
type UserGender string

// Booking id is common between both operators, and must be created as a [UUID](https://datatracker.ietf.org/doc/html/rfc4122) by whoever initiates the booking.  Usage of a [4 UUID](https://datatracker.ietf.org/doc/html/rfc4122#section-4.4) generation algorithm is advised.
type BookingId = openapi_types.UUID

// Status of the booking.
type BookingStatus string

// ArrivalLat defines model for arrivalLat.
type ArrivalLat = float32

// ArrivalLng defines model for arrivalLng.
type ArrivalLng = float32

// ArrivalRadius defines model for arrivalRadius.
type ArrivalRadius = float32

// Count defines model for count.
type Count = int

// DepartureDate defines model for departureDate.
type DepartureDate = int

// DepartureLat defines model for departureLat.
type DepartureLat = float32

// DepartureLng defines model for departureLng.
type DepartureLng = float32

// DepartureRadius defines model for departureRadius.
type DepartureRadius = float32

// DepartureTimeOfDay defines model for departureTimeOfDay.
type DepartureTimeOfDay = string

// DepartureWeekdays defines model for departureWeekdays.
type DepartureWeekdays = []string

// MaxDepartureDate defines model for maxDepartureDate.
type MaxDepartureDate = int

// MinDepartureDate defines model for minDepartureDate.
type MinDepartureDate = int

// TimeDelta defines model for timeDelta.
type TimeDelta = int

// BadRequest defines model for BadRequest.
type BadRequest struct {
	// Explain why the request couldn't be processed.
	Error *string `json:"error,omitempty"`
}

// PostBookingEventsJSONBody defines parameters for PostBookingEvents.
type PostBookingEventsJSONBody = CarpoolBookingEvent

// PostBookingsJSONBody defines parameters for PostBookings.
type PostBookingsJSONBody = Booking

// PatchBookingsParams defines parameters for PatchBookings.
type PatchBookingsParams struct {
	// New status of the Booking.
	Status BookingStatus `form:"status" json:"status"`

	// Free text content of a message. The message can contain explanations on the status change.
	Message *string `form:"message,omitempty" json:"message,omitempty"`
}

// GetDriverJourneysParams defines parameters for GetDriverJourneys.
type GetDriverJourneysParams struct {
	// Latitude of searched departure point.
	DepartureLat DepartureLat `form:"departureLat" json:"departureLat"`

	// Longitude of searched departure point.
	DepartureLng DepartureLng `form:"departureLng" json:"departureLng"`

	// Latitude of searched arrival point.
	ArrivalLat ArrivalLat `form:"arrivalLat" json:"arrivalLat"`

	// Longitude of searched arrival point.
	ArrivalLng ArrivalLng `form:"arrivalLng" json:"arrivalLng"`

	// Departure datetime using a UNIX UTC timestamp in seconds.
	DepartureDate DepartureDate `form:"departureDate" json:"departureDate"`

	// Time margin in seconds. The retrieved journeys must match the given time parameters within a +`timeDelta` / -`timeDelta` interval .
	TimeDelta *TimeDelta `form:"timeDelta,omitempty" json:"timeDelta,omitempty"`

	// Search radius in kilometers around the departure point.
	DepartureRadius *DepartureRadius `form:"departureRadius,omitempty" json:"departureRadius,omitempty"`

	// Search radius in kilometers around the arrival point.
	ArrivalRadius *ArrivalRadius `form:"arrivalRadius,omitempty" json:"arrivalRadius,omitempty"`

	// Maximum number of returned results. If missing, all matching results are returned.
	Count *Count `form:"count,omitempty" json:"count,omitempty"`
}

// GetDriverRegularTripsParams defines parameters for GetDriverRegularTrips.
type GetDriverRegularTripsParams struct {
	// Latitude of searched departure point.
	DepartureLat DepartureLat `form:"departureLat" json:"departureLat"`

	// Longitude of searched departure point.
	DepartureLng DepartureLng `form:"departureLng" json:"departureLng"`

	// Latitude of searched arrival point.
	ArrivalLat ArrivalLat `form:"arrivalLat" json:"arrivalLat"`

	// Longitude of searched arrival point.
	ArrivalLng ArrivalLng `form:"arrivalLng" json:"arrivalLng"`

	// Departure time of day represented as [RFC3339 partial-time](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6).
	DepartureTimeOfDay DepartureTimeOfDay `form:"departureTimeOfDay" json:"departureTimeOfDay"`

	// Departure days of week. The retrieved trips should have at least one schedule applicable on one of the departureWeekdays.
	DepartureWeekdays *DepartureWeekdays `form:"departureWeekdays,omitempty" json:"departureWeekdays,omitempty"`

	// Time margin in seconds. The retrieved journeys must match the given time parameters within a +`timeDelta` / -`timeDelta` interval .
	TimeDelta *TimeDelta `form:"timeDelta,omitempty" json:"timeDelta,omitempty"`

	// Search radius in kilometers around the departure point.
	DepartureRadius *DepartureRadius `form:"departureRadius,omitempty" json:"departureRadius,omitempty"`

	// Search radius in kilometers around the arrival point.
	ArrivalRadius *ArrivalRadius `form:"arrivalRadius,omitempty" json:"arrivalRadius,omitempty"`

	// Minimum date of departure for the returned journeys. Datetime using a UNIX UTC timestamp in seconds.
	MinDepartureDate *MinDepartureDate `form:"minDepartureDate,omitempty" json:"minDepartureDate,omitempty"`

	// Maximum date of departure for the returned journeys. Datetime using a UNIX UTC timestamp in seconds.
	MaxDepartureDate *MaxDepartureDate `form:"maxDepartureDate,omitempty" json:"maxDepartureDate,omitempty"`

	// Maximum number of returned results. If missing, all matching results are returned.
	Count *Count `form:"count,omitempty" json:"count,omitempty"`
}

// PostConnectionsJSONBody defines parameters for PostConnections.
type PostConnectionsJSONBody struct {
	// Booking id is common between both operators, and must be created as a [UUID](https://datatracker.ietf.org/doc/html/rfc4122) by whoever initiates the booking.  Usage of a [4 UUID](https://datatracker.ietf.org/doc/html/rfc4122#section-4.4) generation algorithm is advised.
	BookingId *BookingId `json:"bookingId,omitempty"`

	// ID of the Driver's journey to which the message is related (if any). Unique given the `Driver`'s `operator` property.
	DriverJourneyId *string `json:"driverJourneyId,omitempty"`
	From            User    `json:"from"`

	// Free text content of a message. The message can contain all the details (phone number, email, etc.) allowing the recipient to call back the sender in order to carpool with him/her.
	Message string `json:"message"`

	// ID of the Passenger's journey to which the message is related (if any). Unique given the `Passenger`'s `operator` property.
	PassengerJourneyId *string `json:"passengerJourneyId,omitempty"`

	// Defines if the recipient of this message is either the driver or the passenger.
	RecipientCarpoolerType PostConnectionsJSONBodyRecipientCarpoolerType `json:"recipientCarpoolerType"`
	To                     User                                          `json:"to"`
}

// PostConnectionsJSONBodyRecipientCarpoolerType defines parameters for PostConnections.
type PostConnectionsJSONBodyRecipientCarpoolerType string

// GetPassengerJourneysParams defines parameters for GetPassengerJourneys.
type GetPassengerJourneysParams struct {
	// Latitude of searched departure point.
	DepartureLat DepartureLat `form:"departureLat" json:"departureLat"`

	// Longitude of searched departure point.
	DepartureLng DepartureLng `form:"departureLng" json:"departureLng"`

	// Latitude of searched arrival point.
	ArrivalLat ArrivalLat `form:"arrivalLat" json:"arrivalLat"`

	// Longitude of searched arrival point.
	ArrivalLng ArrivalLng `form:"arrivalLng" json:"arrivalLng"`

	// Departure datetime using a UNIX UTC timestamp in seconds.
	DepartureDate DepartureDate `form:"departureDate" json:"departureDate"`

	// Time margin in seconds. The retrieved journeys must match the given time parameters within a +`timeDelta` / -`timeDelta` interval .
	TimeDelta *TimeDelta `form:"timeDelta,omitempty" json:"timeDelta,omitempty"`

	// Search radius in kilometers around the departure point.
	DepartureRadius *DepartureRadius `form:"departureRadius,omitempty" json:"departureRadius,omitempty"`

	// Search radius in kilometers around the arrival point.
	ArrivalRadius *ArrivalRadius `form:"arrivalRadius,omitempty" json:"arrivalRadius,omitempty"`

	// Maximum number of returned results. If missing, all matching results are returned.
	Count *Count `form:"count,omitempty" json:"count,omitempty"`
}

// GetPassengerRegularTripsParams defines parameters for GetPassengerRegularTrips.
type GetPassengerRegularTripsParams struct {
	// Latitude of searched departure point.
	DepartureLat DepartureLat `form:"departureLat" json:"departureLat"`

	// Longitude of searched departure point.
	DepartureLng DepartureLng `form:"departureLng" json:"departureLng"`

	// Latitude of searched arrival point.
	ArrivalLat ArrivalLat `form:"arrivalLat" json:"arrivalLat"`

	// Longitude of searched arrival point.
	ArrivalLng ArrivalLng `form:"arrivalLng" json:"arrivalLng"`

	// Departure time of day represented as [RFC3339 partial-time](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6).
	DepartureTimeOfDay DepartureTimeOfDay `form:"departureTimeOfDay" json:"departureTimeOfDay"`

	// Departure days of week. The retrieved trips should have at least one schedule applicable on one of the departureWeekdays.
	DepartureWeekdays *DepartureWeekdays `form:"departureWeekdays,omitempty" json:"departureWeekdays,omitempty"`

	// Time margin in seconds. The retrieved journeys must match the given time parameters within a +`timeDelta` / -`timeDelta` interval .
	TimeDelta *TimeDelta `form:"timeDelta,omitempty" json:"timeDelta,omitempty"`

	// Search radius in kilometers around the departure point.
	DepartureRadius *DepartureRadius `form:"departureRadius,omitempty" json:"departureRadius,omitempty"`

	// Search radius in kilometers around the arrival point.
	ArrivalRadius *ArrivalRadius `form:"arrivalRadius,omitempty" json:"arrivalRadius,omitempty"`

	// Minimum date of departure for the returned journeys. Datetime using a UNIX UTC timestamp in seconds.
	MinDepartureDate *MinDepartureDate `form:"minDepartureDate,omitempty" json:"minDepartureDate,omitempty"`

	// Maximum date of departure for the returned journeys. Datetime using a UNIX UTC timestamp in seconds.
	MaxDepartureDate *MaxDepartureDate `form:"maxDepartureDate,omitempty" json:"maxDepartureDate,omitempty"`

	// Maximum number of returned results. If missing, all matching results are returned.
	Count *Count `form:"count,omitempty" json:"count,omitempty"`
}

// PostBookingEventsJSONRequestBody defines body for PostBookingEvents for application/json ContentType.
type PostBookingEventsJSONRequestBody = PostBookingEventsJSONBody

// PostBookingsJSONRequestBody defines body for PostBookings for application/json ContentType.
type PostBookingsJSONRequestBody = PostBookingsJSONBody

// PostConnectionsJSONRequestBody defines body for PostConnections for application/json ContentType.
type PostConnectionsJSONRequestBody PostConnectionsJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostBookingEvents request with any body
	PostBookingEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBookingEvents(ctx context.Context, body PostBookingEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBookings request with any body
	PostBookingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBookings(ctx context.Context, body PostBookingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBookings request
	GetBookings(ctx context.Context, bookingId BookingId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchBookings request
	PatchBookings(ctx context.Context, bookingId BookingId, params *PatchBookingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDriverJourneys request
	GetDriverJourneys(ctx context.Context, params *GetDriverJourneysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDriverRegularTrips request
	GetDriverRegularTrips(ctx context.Context, params *GetDriverRegularTripsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostConnections request with any body
	PostConnectionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostConnections(ctx context.Context, body PostConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPassengerJourneys request
	GetPassengerJourneys(ctx context.Context, params *GetPassengerJourneysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPassengerRegularTrips request
	GetPassengerRegularTrips(ctx context.Context, params *GetPassengerRegularTripsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostBookingEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBookingEventsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBookingEvents(ctx context.Context, body PostBookingEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBookingEventsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBookingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBookingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBookings(ctx context.Context, body PostBookingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBookingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBookings(ctx context.Context, bookingId BookingId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBookingsRequest(c.Server, bookingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchBookings(ctx context.Context, bookingId BookingId, params *PatchBookingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchBookingsRequest(c.Server, bookingId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDriverJourneys(ctx context.Context, params *GetDriverJourneysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDriverJourneysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDriverRegularTrips(ctx context.Context, params *GetDriverRegularTripsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDriverRegularTripsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostConnectionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostConnectionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostConnections(ctx context.Context, body PostConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostConnectionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPassengerJourneys(ctx context.Context, params *GetPassengerJourneysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPassengerJourneysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPassengerRegularTrips(ctx context.Context, params *GetPassengerRegularTripsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPassengerRegularTripsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostBookingEventsRequest calls the generic PostBookingEvents builder with application/json body
func NewPostBookingEventsRequest(server string, body PostBookingEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBookingEventsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBookingEventsRequestWithBody generates requests for PostBookingEvents with any type of body
func NewPostBookingEventsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/booking_events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostBookingsRequest calls the generic PostBookings builder with application/json body
func NewPostBookingsRequest(server string, body PostBookingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBookingsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBookingsRequestWithBody generates requests for PostBookings with any type of body
func NewPostBookingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBookingsRequest generates requests for GetBookings
func NewGetBookingsRequest(server string, bookingId BookingId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookingId", runtime.ParamLocationPath, bookingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchBookingsRequest generates requests for PatchBookings
func NewPatchBookingsRequest(server string, bookingId BookingId, params *PatchBookingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookingId", runtime.ParamLocationPath, bookingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, params.Status); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Message != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message", runtime.ParamLocationQuery, *params.Message); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDriverJourneysRequest generates requests for GetDriverJourneys
func NewGetDriverJourneysRequest(server string, params *GetDriverJourneysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/driver_journeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLat", runtime.ParamLocationQuery, params.DepartureLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLng", runtime.ParamLocationQuery, params.DepartureLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLat", runtime.ParamLocationQuery, params.ArrivalLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLng", runtime.ParamLocationQuery, params.ArrivalLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureDate", runtime.ParamLocationQuery, params.DepartureDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.TimeDelta != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeDelta", runtime.ParamLocationQuery, *params.TimeDelta); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DepartureRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureRadius", runtime.ParamLocationQuery, *params.DepartureRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ArrivalRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalRadius", runtime.ParamLocationQuery, *params.ArrivalRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDriverRegularTripsRequest generates requests for GetDriverRegularTrips
func NewGetDriverRegularTripsRequest(server string, params *GetDriverRegularTripsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/driver_regular_trips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLat", runtime.ParamLocationQuery, params.DepartureLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLng", runtime.ParamLocationQuery, params.DepartureLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLat", runtime.ParamLocationQuery, params.ArrivalLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLng", runtime.ParamLocationQuery, params.ArrivalLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureTimeOfDay", runtime.ParamLocationQuery, params.DepartureTimeOfDay); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.DepartureWeekdays != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "departureWeekdays", runtime.ParamLocationQuery, *params.DepartureWeekdays); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TimeDelta != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeDelta", runtime.ParamLocationQuery, *params.TimeDelta); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DepartureRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureRadius", runtime.ParamLocationQuery, *params.DepartureRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ArrivalRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalRadius", runtime.ParamLocationQuery, *params.ArrivalRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MinDepartureDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDepartureDate", runtime.ParamLocationQuery, *params.MinDepartureDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MaxDepartureDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxDepartureDate", runtime.ParamLocationQuery, *params.MaxDepartureDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostConnectionsRequest calls the generic PostConnections builder with application/json body
func NewPostConnectionsRequest(server string, body PostConnectionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostConnectionsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostConnectionsRequestWithBody generates requests for PostConnections with any type of body
func NewPostConnectionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPassengerJourneysRequest generates requests for GetPassengerJourneys
func NewGetPassengerJourneysRequest(server string, params *GetPassengerJourneysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/passenger_journeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLat", runtime.ParamLocationQuery, params.DepartureLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLng", runtime.ParamLocationQuery, params.DepartureLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLat", runtime.ParamLocationQuery, params.ArrivalLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLng", runtime.ParamLocationQuery, params.ArrivalLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureDate", runtime.ParamLocationQuery, params.DepartureDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.TimeDelta != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeDelta", runtime.ParamLocationQuery, *params.TimeDelta); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DepartureRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureRadius", runtime.ParamLocationQuery, *params.DepartureRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ArrivalRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalRadius", runtime.ParamLocationQuery, *params.ArrivalRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPassengerRegularTripsRequest generates requests for GetPassengerRegularTrips
func NewGetPassengerRegularTripsRequest(server string, params *GetPassengerRegularTripsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/passenger_regular_trips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLat", runtime.ParamLocationQuery, params.DepartureLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureLng", runtime.ParamLocationQuery, params.DepartureLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLat", runtime.ParamLocationQuery, params.ArrivalLat); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalLng", runtime.ParamLocationQuery, params.ArrivalLng); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureTimeOfDay", runtime.ParamLocationQuery, params.DepartureTimeOfDay); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.DepartureWeekdays != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "departureWeekdays", runtime.ParamLocationQuery, *params.DepartureWeekdays); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TimeDelta != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeDelta", runtime.ParamLocationQuery, *params.TimeDelta); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DepartureRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departureRadius", runtime.ParamLocationQuery, *params.DepartureRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ArrivalRadius != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrivalRadius", runtime.ParamLocationQuery, *params.ArrivalRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MinDepartureDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDepartureDate", runtime.ParamLocationQuery, *params.MinDepartureDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MaxDepartureDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxDepartureDate", runtime.ParamLocationQuery, *params.MaxDepartureDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostBookingEvents request with any body
	PostBookingEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBookingEventsResponse, error)

	PostBookingEventsWithResponse(ctx context.Context, body PostBookingEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBookingEventsResponse, error)

	// PostBookings request with any body
	PostBookingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBookingsResponse, error)

	PostBookingsWithResponse(ctx context.Context, body PostBookingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBookingsResponse, error)

	// GetBookings request
	GetBookingsWithResponse(ctx context.Context, bookingId BookingId, reqEditors ...RequestEditorFn) (*GetBookingsResponse, error)

	// PatchBookings request
	PatchBookingsWithResponse(ctx context.Context, bookingId BookingId, params *PatchBookingsParams, reqEditors ...RequestEditorFn) (*PatchBookingsResponse, error)

	// GetDriverJourneys request
	GetDriverJourneysWithResponse(ctx context.Context, params *GetDriverJourneysParams, reqEditors ...RequestEditorFn) (*GetDriverJourneysResponse, error)

	// GetDriverRegularTrips request
	GetDriverRegularTripsWithResponse(ctx context.Context, params *GetDriverRegularTripsParams, reqEditors ...RequestEditorFn) (*GetDriverRegularTripsResponse, error)

	// PostConnections request with any body
	PostConnectionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostConnectionsResponse, error)

	PostConnectionsWithResponse(ctx context.Context, body PostConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostConnectionsResponse, error)

	// GetPassengerJourneys request
	GetPassengerJourneysWithResponse(ctx context.Context, params *GetPassengerJourneysParams, reqEditors ...RequestEditorFn) (*GetPassengerJourneysResponse, error)

	// GetPassengerRegularTrips request
	GetPassengerRegularTripsWithResponse(ctx context.Context, params *GetPassengerRegularTripsParams, reqEditors ...RequestEditorFn) (*GetPassengerRegularTripsResponse, error)

	// GetStatus request
	GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error)
}

type PostBookingEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		// Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostBookingEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBookingEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBookingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Booking
	JSON400      *struct {
		// Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostBookingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBookingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBookingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Booking
	JSON400      *struct {
		// Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
	JSON404 *struct {
		// Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBookingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBookingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchBookingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		// Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
	JSON404 *struct {
		// Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
	JSON409 *struct {
		// Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PatchBookingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchBookingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDriverJourneysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DriverJourney
	JSON400      *struct {
		// Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDriverJourneysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDriverJourneysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDriverRegularTripsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Car *Car `json:"car,omitempty"`

		// Walking distance from the requested departure location
		// to the pick-up location.
		DepartureToPickupWalkingDistance *int `json:"departureToPickupWalkingDistance,omitempty"`

		// Walking duration from the requested departure location
		// to the pick-up location.
		DepartureToPickupWalkingDuration *int `json:"departureToPickupWalkingDuration,omitempty"`

		// Walking
		// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
		// from the requested departure location to the pick-up location.
		DepartureToPickupWalkingPolyline *string `json:"departureToPickupWalkingPolyline,omitempty"`

		// Carpooling distance in meters.
		Distance *int `json:"distance,omitempty"`
		Driver   User `json:"driver"`

		// String representing the arrival address of the driver.
		DriverArrivalAddress *string `json:"driverArrivalAddress,omitempty"`

		// Latitude of the arrival.
		DriverArrivalLat *float64 `json:"driverArrivalLat,omitempty"`

		// Longitude of the arrival.
		DriverArrivalLng *float64 `json:"driverArrivalLng,omitempty"`

		// String representing the departure address of the driver.
		DriverDepartureAddress *string `json:"driverDepartureAddress,omitempty"`

		// Latitude of the departure.
		DriverDepartureLat *float64 `json:"driverDepartureLat,omitempty"`

		// Longitude of the departure.
		DriverDepartureLng *float64 `json:"driverDepartureLng,omitempty"`

		// Walking distance to the requested arrival location
		// from the drop-off location.
		DropoffToArrivalWalkingDistance *int `json:"dropoffToArrivalWalkingDistance,omitempty"`

		// Walking duration to the requested arrival location
		// from the drop-off location.
		DropoffToArrivalWalkingDuration *int `json:"dropoffToArrivalWalkingDuration,omitempty"`

		// Walking
		// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
		// to the requested arrival location from the drop-off location.
		DropoffToArrivalWalkingPolyline *string `json:"dropoffToArrivalWalkingPolyline,omitempty"`

		// Carpooling duration in seconds.
		Duration int `json:"duration"`

		// Carpooling journey itinerary as a
		// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm), compressed at  level 5.
		JourneyPolyline *string `json:"journeyPolyline,omitempty"`

		// The operator identifier. MUST be a Root Domain (example operator.org) owned by the operator or a Fully Qualified Domain Name (example carpool.mycity.com) exclusively operated by the operator. A given operator SHOULD always send the same value.
		Operator string `json:"operator"`

		// String representing the drop-off address.
		PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

		// Latitude of the passenger drop-off point.
		PassengerDropLat float64 `json:"passengerDropLat"`

		// Longitude of the passenger drop-off point.
		PassengerDropLng float64 `json:"passengerDropLng"`

		// String representing the pickup-up address.
		PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

		// Latitude of the passenger pick-up point.
		PassengerPickupLat float64 `json:"passengerPickupLat"`

		// Longitude of the passenger pick-up point.
		PassengerPickupLng float64      `json:"passengerPickupLng"`
		Preferences        *Preferences `json:"preferences,omitempty"`
		Schedules          *[]Schedule  `json:"schedules,omitempty"`

		// URL of the trip on the webservice provider platform.
		WebUrl *string `json:"webUrl,omitempty"`
	}
	JSON400 *struct {
		// Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDriverRegularTripsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDriverRegularTripsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		// Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPassengerJourneysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PassengerJourney
	JSON400      *struct {
		// Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPassengerJourneysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPassengerJourneysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPassengerRegularTripsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Carpooling distance in meters.
		Distance *int `json:"distance,omitempty"`

		// String representing the arrival address of the driver.
		DriverArrivalAddress *string `json:"driverArrivalAddress,omitempty"`

		// Latitude of the arrival.
		DriverArrivalLat *float64 `json:"driverArrivalLat,omitempty"`

		// Longitude of the arrival.
		DriverArrivalLng *float64 `json:"driverArrivalLng,omitempty"`

		// String representing the departure address of the driver.
		DriverDepartureAddress *string `json:"driverDepartureAddress,omitempty"`

		// Latitude of the departure.
		DriverDepartureLat *float64 `json:"driverDepartureLat,omitempty"`

		// Longitude of the departure.
		DriverDepartureLng *float64 `json:"driverDepartureLng,omitempty"`

		// Carpooling duration in seconds.
		Duration int `json:"duration"`

		// Carpooling journey itinerary as a
		// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm), compressed at  level 5.
		JourneyPolyline *string `json:"journeyPolyline,omitempty"`

		// The operator identifier. MUST be a Root Domain (example operator.org) owned by the operator or a Fully Qualified Domain Name (example carpool.mycity.com) exclusively operated by the operator. A given operator SHOULD always send the same value.
		Operator  string `json:"operator"`
		Passenger User   `json:"passenger"`

		// String representing the drop-off address.
		PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

		// Latitude of the passenger drop-off point.
		PassengerDropLat float64 `json:"passengerDropLat"`

		// Longitude of the passenger drop-off point.
		PassengerDropLng float64 `json:"passengerDropLng"`

		// String representing the pickup-up address.
		PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

		// Latitude of the passenger pick-up point.
		PassengerPickupLat float64 `json:"passengerPickupLat"`

		// Longitude of the passenger pick-up point.
		PassengerPickupLng float64      `json:"passengerPickupLng"`
		Preferences        *Preferences `json:"preferences,omitempty"`
		Schedules          *[]Schedule  `json:"schedules,omitempty"`

		// URL of the trip on the webservice provider platform.
		WebUrl *string `json:"webUrl,omitempty"`
	}
	JSON400 *struct {
		// Explain why the request couldn't be processed.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPassengerRegularTripsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPassengerRegularTripsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostBookingEventsWithBodyWithResponse request with arbitrary body returning *PostBookingEventsResponse
func (c *ClientWithResponses) PostBookingEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBookingEventsResponse, error) {
	rsp, err := c.PostBookingEventsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBookingEventsResponse(rsp)
}

func (c *ClientWithResponses) PostBookingEventsWithResponse(ctx context.Context, body PostBookingEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBookingEventsResponse, error) {
	rsp, err := c.PostBookingEvents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBookingEventsResponse(rsp)
}

// PostBookingsWithBodyWithResponse request with arbitrary body returning *PostBookingsResponse
func (c *ClientWithResponses) PostBookingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBookingsResponse, error) {
	rsp, err := c.PostBookingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBookingsResponse(rsp)
}

func (c *ClientWithResponses) PostBookingsWithResponse(ctx context.Context, body PostBookingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBookingsResponse, error) {
	rsp, err := c.PostBookings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBookingsResponse(rsp)
}

// GetBookingsWithResponse request returning *GetBookingsResponse
func (c *ClientWithResponses) GetBookingsWithResponse(ctx context.Context, bookingId BookingId, reqEditors ...RequestEditorFn) (*GetBookingsResponse, error) {
	rsp, err := c.GetBookings(ctx, bookingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBookingsResponse(rsp)
}

// PatchBookingsWithResponse request returning *PatchBookingsResponse
func (c *ClientWithResponses) PatchBookingsWithResponse(ctx context.Context, bookingId BookingId, params *PatchBookingsParams, reqEditors ...RequestEditorFn) (*PatchBookingsResponse, error) {
	rsp, err := c.PatchBookings(ctx, bookingId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchBookingsResponse(rsp)
}

// GetDriverJourneysWithResponse request returning *GetDriverJourneysResponse
func (c *ClientWithResponses) GetDriverJourneysWithResponse(ctx context.Context, params *GetDriverJourneysParams, reqEditors ...RequestEditorFn) (*GetDriverJourneysResponse, error) {
	rsp, err := c.GetDriverJourneys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDriverJourneysResponse(rsp)
}

// GetDriverRegularTripsWithResponse request returning *GetDriverRegularTripsResponse
func (c *ClientWithResponses) GetDriverRegularTripsWithResponse(ctx context.Context, params *GetDriverRegularTripsParams, reqEditors ...RequestEditorFn) (*GetDriverRegularTripsResponse, error) {
	rsp, err := c.GetDriverRegularTrips(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDriverRegularTripsResponse(rsp)
}

// PostConnectionsWithBodyWithResponse request with arbitrary body returning *PostConnectionsResponse
func (c *ClientWithResponses) PostConnectionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostConnectionsResponse, error) {
	rsp, err := c.PostConnectionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostConnectionsResponse(rsp)
}

func (c *ClientWithResponses) PostConnectionsWithResponse(ctx context.Context, body PostConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostConnectionsResponse, error) {
	rsp, err := c.PostConnections(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostConnectionsResponse(rsp)
}

// GetPassengerJourneysWithResponse request returning *GetPassengerJourneysResponse
func (c *ClientWithResponses) GetPassengerJourneysWithResponse(ctx context.Context, params *GetPassengerJourneysParams, reqEditors ...RequestEditorFn) (*GetPassengerJourneysResponse, error) {
	rsp, err := c.GetPassengerJourneys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPassengerJourneysResponse(rsp)
}

// GetPassengerRegularTripsWithResponse request returning *GetPassengerRegularTripsResponse
func (c *ClientWithResponses) GetPassengerRegularTripsWithResponse(ctx context.Context, params *GetPassengerRegularTripsParams, reqEditors ...RequestEditorFn) (*GetPassengerRegularTripsResponse, error) {
	rsp, err := c.GetPassengerRegularTrips(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPassengerRegularTripsResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error) {
	rsp, err := c.GetStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// ParsePostBookingEventsResponse parses an HTTP response from a PostBookingEventsWithResponse call
func ParsePostBookingEventsResponse(rsp *http.Response) (*PostBookingEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBookingEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostBookingsResponse parses an HTTP response from a PostBookingsWithResponse call
func ParsePostBookingsResponse(rsp *http.Response) (*PostBookingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBookingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Booking
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBookingsResponse parses an HTTP response from a GetBookingsWithResponse call
func ParseGetBookingsResponse(rsp *http.Response) (*GetBookingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBookingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Booking
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchBookingsResponse parses an HTTP response from a PatchBookingsWithResponse call
func ParsePatchBookingsResponse(rsp *http.Response) (*PatchBookingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchBookingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			// Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetDriverJourneysResponse parses an HTTP response from a GetDriverJourneysWithResponse call
func ParseGetDriverJourneysResponse(rsp *http.Response) (*GetDriverJourneysResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDriverJourneysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DriverJourney
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetDriverRegularTripsResponse parses an HTTP response from a GetDriverRegularTripsWithResponse call
func ParseGetDriverRegularTripsResponse(rsp *http.Response) (*GetDriverRegularTripsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDriverRegularTripsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Car *Car `json:"car,omitempty"`

			// Walking distance from the requested departure location
			// to the pick-up location.
			DepartureToPickupWalkingDistance *int `json:"departureToPickupWalkingDistance,omitempty"`

			// Walking duration from the requested departure location
			// to the pick-up location.
			DepartureToPickupWalkingDuration *int `json:"departureToPickupWalkingDuration,omitempty"`

			// Walking
			// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
			// from the requested departure location to the pick-up location.
			DepartureToPickupWalkingPolyline *string `json:"departureToPickupWalkingPolyline,omitempty"`

			// Carpooling distance in meters.
			Distance *int `json:"distance,omitempty"`
			Driver   User `json:"driver"`

			// String representing the arrival address of the driver.
			DriverArrivalAddress *string `json:"driverArrivalAddress,omitempty"`

			// Latitude of the arrival.
			DriverArrivalLat *float64 `json:"driverArrivalLat,omitempty"`

			// Longitude of the arrival.
			DriverArrivalLng *float64 `json:"driverArrivalLng,omitempty"`

			// String representing the departure address of the driver.
			DriverDepartureAddress *string `json:"driverDepartureAddress,omitempty"`

			// Latitude of the departure.
			DriverDepartureLat *float64 `json:"driverDepartureLat,omitempty"`

			// Longitude of the departure.
			DriverDepartureLng *float64 `json:"driverDepartureLng,omitempty"`

			// Walking distance to the requested arrival location
			// from the drop-off location.
			DropoffToArrivalWalkingDistance *int `json:"dropoffToArrivalWalkingDistance,omitempty"`

			// Walking duration to the requested arrival location
			// from the drop-off location.
			DropoffToArrivalWalkingDuration *int `json:"dropoffToArrivalWalkingDuration,omitempty"`

			// Walking
			// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
			// to the requested arrival location from the drop-off location.
			DropoffToArrivalWalkingPolyline *string `json:"dropoffToArrivalWalkingPolyline,omitempty"`

			// Carpooling duration in seconds.
			Duration int `json:"duration"`

			// Carpooling journey itinerary as a
			// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm), compressed at  level 5.
			JourneyPolyline *string `json:"journeyPolyline,omitempty"`

			// The operator identifier. MUST be a Root Domain (example operator.org) owned by the operator or a Fully Qualified Domain Name (example carpool.mycity.com) exclusively operated by the operator. A given operator SHOULD always send the same value.
			Operator string `json:"operator"`

			// String representing the drop-off address.
			PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

			// Latitude of the passenger drop-off point.
			PassengerDropLat float64 `json:"passengerDropLat"`

			// Longitude of the passenger drop-off point.
			PassengerDropLng float64 `json:"passengerDropLng"`

			// String representing the pickup-up address.
			PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

			// Latitude of the passenger pick-up point.
			PassengerPickupLat float64 `json:"passengerPickupLat"`

			// Longitude of the passenger pick-up point.
			PassengerPickupLng float64      `json:"passengerPickupLng"`
			Preferences        *Preferences `json:"preferences,omitempty"`
			Schedules          *[]Schedule  `json:"schedules,omitempty"`

			// URL of the trip on the webservice provider platform.
			WebUrl *string `json:"webUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostConnectionsResponse parses an HTTP response from a PostConnectionsWithResponse call
func ParsePostConnectionsResponse(rsp *http.Response) (*PostConnectionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPassengerJourneysResponse parses an HTTP response from a GetPassengerJourneysWithResponse call
func ParseGetPassengerJourneysResponse(rsp *http.Response) (*GetPassengerJourneysResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPassengerJourneysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PassengerJourney
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPassengerRegularTripsResponse parses an HTTP response from a GetPassengerRegularTripsWithResponse call
func ParseGetPassengerRegularTripsResponse(rsp *http.Response) (*GetPassengerRegularTripsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPassengerRegularTripsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Carpooling distance in meters.
			Distance *int `json:"distance,omitempty"`

			// String representing the arrival address of the driver.
			DriverArrivalAddress *string `json:"driverArrivalAddress,omitempty"`

			// Latitude of the arrival.
			DriverArrivalLat *float64 `json:"driverArrivalLat,omitempty"`

			// Longitude of the arrival.
			DriverArrivalLng *float64 `json:"driverArrivalLng,omitempty"`

			// String representing the departure address of the driver.
			DriverDepartureAddress *string `json:"driverDepartureAddress,omitempty"`

			// Latitude of the departure.
			DriverDepartureLat *float64 `json:"driverDepartureLat,omitempty"`

			// Longitude of the departure.
			DriverDepartureLng *float64 `json:"driverDepartureLng,omitempty"`

			// Carpooling duration in seconds.
			Duration int `json:"duration"`

			// Carpooling journey itinerary as a
			// [Google Encoded Polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm), compressed at  level 5.
			JourneyPolyline *string `json:"journeyPolyline,omitempty"`

			// The operator identifier. MUST be a Root Domain (example operator.org) owned by the operator or a Fully Qualified Domain Name (example carpool.mycity.com) exclusively operated by the operator. A given operator SHOULD always send the same value.
			Operator  string `json:"operator"`
			Passenger User   `json:"passenger"`

			// String representing the drop-off address.
			PassengerDropAddress *string `json:"passengerDropAddress,omitempty"`

			// Latitude of the passenger drop-off point.
			PassengerDropLat float64 `json:"passengerDropLat"`

			// Longitude of the passenger drop-off point.
			PassengerDropLng float64 `json:"passengerDropLng"`

			// String representing the pickup-up address.
			PassengerPickupAddress *string `json:"passengerPickupAddress,omitempty"`

			// Latitude of the passenger pick-up point.
			PassengerPickupLat float64 `json:"passengerPickupLat"`

			// Longitude of the passenger pick-up point.
			PassengerPickupLng float64      `json:"passengerPickupLng"`
			Preferences        *Preferences `json:"preferences,omitempty"`
			Schedules          *[]Schedule  `json:"schedules,omitempty"`

			// URL of the trip on the webservice provider platform.
			WebUrl *string `json:"webUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Explain why the request couldn't be processed.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
